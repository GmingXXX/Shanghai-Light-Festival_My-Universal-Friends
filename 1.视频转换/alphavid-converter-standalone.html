<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>é€æ˜è§†é¢‘è½¬æ¢å™¨ - ç¦»çº¿ç‰ˆ</title>
        <meta http-equiv="Cross-Origin-Opener-Policy" content="same-origin">
        <meta http-equiv="Cross-Origin-Embedder-Policy" content="require-corp">
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', 'PingFang SC', 'Hiragino Sans GB', 'Microsoft YaHei', sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
        }

        .container {
            max-width: 1200px;
            margin: 0 auto;
            padding: 20px;
        }

        .header {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 40px 32px;
            text-align: center;
            margin-bottom: 24px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }

        .header h1 {
            font-size: 2.8rem;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            -webkit-background-clip: text;
            -webkit-text-fill-color: transparent;
            background-clip: text;
            margin-bottom: 12px;
            font-weight: 700;
        }

        .header p {
            font-size: 1.2rem;
            color: #666;
            margin-bottom: 8px;
        }

        .header .version {
            font-size: 0.9rem;
            color: #999;
            font-weight: 500;
        }

        .main-content {
            background: rgba(255, 255, 255, 0.95);
            backdrop-filter: blur(10px);
            border-radius: 16px;
            padding: 32px;
            box-shadow: 0 20px 40px rgba(0,0,0,0.1);
        }

        .upload-section {
            margin-bottom: 32px;
        }

        .upload-area {
            border: 3px dashed #d9d9d9;
            border-radius: 12px;
            padding: 60px 20px;
            text-align: center;
            background: #fafafa;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            cursor: pointer;
            position: relative;
            overflow: hidden;
            z-index: 1;
            user-select: none;
        }

        .upload-area::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(102, 126, 234, 0.1), transparent);
            transition: left 0.5s;
        }

        .upload-area:hover {
            border-color: #667eea;
            background: #f0f8ff;
            transform: translateY(-2px);
        }

        .upload-area:hover::before {
            left: 100%;
        }

        .upload-area.dragover {
            border-color: #667eea;
            background: #e6f3ff;
            transform: scale(1.02);
            box-shadow: 0 8px 32px rgba(102, 126, 234, 0.2);
        }

        .upload-icon {
            font-size: 4rem;
            margin-bottom: 20px;
            animation: float 3s ease-in-out infinite;
        }

        @keyframes float {
            0%, 100% { transform: translateY(0px); }
            50% { transform: translateY(-10px); }
        }

        .upload-text {
            font-size: 1.3rem;
            color: #333;
            margin-bottom: 12px;
            font-weight: 600;
        }

        .upload-hint {
            color: #666;
            font-size: 1rem;
            line-height: 1.6;
        }

        .file-input {
            display: none;
        }

        .controls {
            display: flex;
            flex-wrap: wrap;
            gap: 12px;
            justify-content: center;
            margin: 24px 0;
        }

        .btn {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
            border: none;
            padding: 14px 28px;
            border-radius: 8px;
            font-size: 1rem;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s cubic-bezier(0.4, 0, 0.2, 1);
            position: relative;
            overflow: hidden;
            min-width: 120px;
        }

        .btn::before {
            content: '';
            position: absolute;
            top: 0;
            left: -100%;
            width: 100%;
            height: 100%;
            background: linear-gradient(90deg, transparent, rgba(255,255,255,0.2), transparent);
            transition: left 0.5s;
        }

        .btn:hover {
            transform: translateY(-3px);
            box-shadow: 0 12px 24px rgba(102, 126, 234, 0.4);
        }

        .btn:hover::before {
            left: 100%;
        }

        .btn:active {
            transform: translateY(-1px);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none;
        }

        .btn.secondary {
            background: #6c757d;
        }

        .btn.danger {
            background: linear-gradient(135deg, #dc3545 0%, #c82333 100%);
        }

        .settings-panel {
            background: #f8f9fa;
            border-radius: 12px;
            padding: 24px;
            margin: 24px 0;
            border: 1px solid #e9ecef;
            display: none;
        }

        .settings-panel.show {
            display: block;
            animation: slideDown 0.3s ease;
        }

        @keyframes slideDown {
            from {
                opacity: 0;
                transform: translateY(-20px);
            }
            to {
                opacity: 1;
                transform: translateY(0);
            }
        }

        .settings-panel h3 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.2rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .setting-group {
            margin-bottom: 20px;
        }

        .setting-group label {
            display: block;
            margin-bottom: 8px;
            font-weight: 600;
            color: #555;
        }

        .color-picker-wrapper {
            display: flex;
            align-items: center;
            gap: 12px;
            margin-bottom: 8px;
        }

        .color-picker {
            width: 50px;
            height: 40px;
            border: 2px solid #ddd;
            border-radius: 8px;
            cursor: pointer;
            transition: all 0.3s ease;
        }

        .color-picker:hover {
            border-color: #667eea;
            transform: scale(1.05);
        }

        .slider {
            width: 100%;
            height: 6px;
            border-radius: 3px;
            background: #ddd;
            outline: none;
            -webkit-appearance: none;
            margin: 10px 0;
        }

        .slider::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        .slider::-moz-range-thumb {
            width: 20px;
            height: 20px;
            border-radius: 50%;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            cursor: pointer;
            border: none;
            box-shadow: 0 2px 8px rgba(102, 126, 234, 0.3);
        }

        .file-list {
            margin-top: 32px;
        }

        .file-list h3 {
            color: #333;
            margin-bottom: 20px;
            font-size: 1.3rem;
            display: flex;
            align-items: center;
            gap: 8px;
        }

        .file-item {
            background: white;
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 16px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.05);
            border: 1px solid #f0f0f0;
            transition: all 0.3s ease;
        }

        .file-item:hover {
            box-shadow: 0 8px 24px rgba(0,0,0,0.1);
            transform: translateY(-2px);
        }

        .file-header {
            display: flex;
            justify-content: space-between;
            align-items: flex-start;
            margin-bottom: 16px;
        }

        .file-info h4 {
            color: #333;
            margin-bottom: 8px;
            font-size: 1.1rem;
            word-break: break-all;
        }

        .file-info p {
            color: #666;
            font-size: 0.9rem;
            margin-bottom: 4px;
        }

        .file-actions {
            display: flex;
            gap: 8px;
            flex-shrink: 0;
        }

        .btn-small {
            padding: 8px 16px;
            font-size: 0.9rem;
            min-width: auto;
        }

        .status {
            padding: 8px 16px;
            border-radius: 20px;
            font-size: 0.85rem;
            font-weight: 600;
            text-align: center;
            min-width: 80px;
        }

        .status.pending { background: #fff3cd; color: #856404; }
        .status.processing { background: #d1ecf1; color: #0c5460; }
        .status.success { background: #d4edda; color: #155724; }
        .status.error { background: #f8d7da; color: #721c24; }

        .progress-container {
            margin: 16px 0;
        }

        .progress-bar {
            width: 100%;
            height: 8px;
            background: #e9ecef;
            border-radius: 4px;
            overflow: hidden;
            position: relative;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            border-radius: 4px;
            transition: width 0.3s ease;
            position: relative;
        }

        .progress-fill::after {
            content: '';
            position: absolute;
            top: 0;
            left: 0;
            bottom: 0;
            right: 0;
            background-image: linear-gradient(
                -45deg,
                rgba(255, 255, 255, .2) 25%,
                transparent 25%,
                transparent 50%,
                rgba(255, 255, 255, .2) 50%,
                rgba(255, 255, 255, .2) 75%,
                transparent 75%,
                transparent
            );
            background-size: 50px 50px;
            animation: move 2s linear infinite;
        }

        @keyframes move {
            0% { background-position: 0 0; }
            100% { background-position: 50px 50px; }
        }

        .progress-text {
            margin-top: 10px;
            font-size: 0.9rem;
            color: #666;
        }

        .progress-percentage {
            font-weight: 600;
            color: #667eea;
            font-size: 1rem;
            margin-bottom: 4px;
        }

        .progress-stage {
            font-weight: 500;
            color: #333;
            margin-bottom: 2px;
        }

        .progress-details {
            font-size: 0.8rem;
            color: #888;
            font-style: italic;
        }

        .preview-container {
            margin-top: 16px;
            text-align: center;
        }

        .preview-video {
            max-width: 100%;
            max-height: 300px;
            border-radius: 8px;
            background: 
                repeating-conic-gradient(#f0f0f0 0% 25%, white 0% 50%) 
                50% / 20px 20px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.1);
        }

        .download-section {
            margin-top: 24px;
            padding: 20px;
            background: #f8f9fa;
            border-radius: 12px;
            text-align: center;
        }

        .toast {
            position: fixed;
            top: 20px;
            right: 20px;
            padding: 16px 24px;
            border-radius: 8px;
            color: white;
            font-weight: 600;
            z-index: 1000;
            transform: translateX(400px);
            transition: transform 0.3s ease;
        }

        .toast.show {
            transform: translateX(0);
        }

        .toast.success {
            background: linear-gradient(135deg, #28a745 0%, #20c997 100%);
        }

        .toast.error {
            background: linear-gradient(135deg, #dc3545 0%, #fd7e14 100%);
        }

        .toast.warning {
            background: linear-gradient(135deg, #ffc107 0%, #fd7e14 100%);
            color: #333;
        }

        .loading-overlay {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: rgba(0,0,0,0.8);
            display: none;
            justify-content: center;
            align-items: center;
            z-index: 2000;
        }

        .loading-overlay.show {
            display: flex;
        }

        .loading-spinner {
            width: 60px;
            height: 60px;
            border: 4px solid rgba(255,255,255,0.3);
            border-top: 4px solid white;
            border-radius: 50%;
            animation: spin 1s linear infinite;
        }

        @keyframes spin {
            0% { transform: rotate(0deg); }
            100% { transform: rotate(360deg); }
        }

        .feature-notice {
            background: linear-gradient(135deg, #e3f2fd 0%, #f3e5f5 100%);
            border: 1px solid #bbdefb;
            border-radius: 12px;
            padding: 24px;
            margin-bottom: 24px;
            text-align: center;
        }

        .feature-notice h3 {
            color: #1976d2;
            margin-bottom: 12px;
            font-size: 1.2rem;
        }

        .feature-notice p {
            color: #666;
            line-height: 1.6;
            margin-bottom: 8px;
        }

        .feature-list {
            display: grid;
            grid-template-columns: repeat(auto-fit, minmax(200px, 1fr));
            gap: 16px;
            margin-top: 20px;
        }

        .feature-item {
            background: white;
            padding: 16px;
            border-radius: 8px;
            text-align: center;
            box-shadow: 0 2px 8px rgba(0,0,0,0.05);
        }

        .feature-item .icon {
            font-size: 2rem;
            margin-bottom: 8px;
        }

        .feature-item h4 {
            color: #333;
            margin-bottom: 4px;
            font-size: 0.9rem;
        }

        .feature-item p {
            color: #666;
            font-size: 0.8rem;
        }

        @media (max-width: 768px) {
            .container {
                padding: 12px;
            }

            .header {
                padding: 24px 20px;
            }

            .header h1 {
                font-size: 2rem;
            }

            .main-content {
                padding: 20px;
            }

            .controls {
                flex-direction: column;
                align-items: center;
            }

            .btn {
                width: 100%;
                max-width: 280px;
            }

            .file-header {
                flex-direction: column;
                gap: 12px;
            }

            .file-actions {
                align-self: stretch;
            }

            .btn-small {
                flex: 1;
            }
        }

        .hidden {
            display: none !important;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>ğŸ¬ é€æ˜è§†é¢‘è½¬æ¢å™¨</h1>
            <p>å°†é»‘åº•è§†é¢‘ä¸€é”®è½¬ä¸ºé€æ˜èƒŒæ™¯ï¼Œæ”¯æŒæ‰¹é‡å¤„ç†</p>
            <p class="version">ç¦»çº¿ç‰ˆ v1.0 - æ— éœ€å®‰è£…ï¼Œæ‰“å¼€å³ç”¨</p>
        </div>

        <div class="main-content">
            <div class="feature-notice">
                <h3>ğŸš€ å®Œå…¨ç¦»çº¿è¿è¡Œ</h3>
                <p>è¿™æ˜¯ä¸€ä¸ªå®Œå…¨ç‹¬ç«‹çš„HTMLæ–‡ä»¶ï¼Œä½¿ç”¨æµè§ˆå™¨çš„åŸç”Ÿèƒ½åŠ›å¤„ç†è§†é¢‘</p>
                <p>æ— éœ€å®‰è£…ä»»ä½•è½¯ä»¶ï¼Œæ”¯æŒChromeã€Firefoxã€Safariã€Edgeç­‰ç°ä»£æµè§ˆå™¨</p>
                
                <div class="feature-list">
                    <div class="feature-item">
                        <div class="icon">ğŸ“</div>
                        <h4>å¤šæ ¼å¼æ”¯æŒ</h4>
                        <p>MP4, MOV, WebM</p>
                    </div>
                    <div class="feature-item">
                        <div class="icon">ğŸ¨</div>
                        <h4>å‚æ•°è°ƒèŠ‚</h4>
                        <p>é¢œè‰²ã€å®¹å·®ã€å¹³æ»‘</p>
                    </div>
                    <div class="feature-item">
                        <div class="icon">ğŸ‘€</div>
                        <h4>å®æ—¶é¢„è§ˆ</h4>
                        <p>æ£‹ç›˜æ ¼èƒŒæ™¯é¢„è§ˆ</p>
                    </div>
                    <div class="feature-item">
                        <div class="icon">âš¡</div>
                        <h4>æœ¬åœ°å¤„ç†</h4>
                        <p>æ•°æ®ä¸ä¸Šä¼ äº‘ç«¯</p>
                    </div>
                    <div class="feature-item">
                        <div class="icon">ğŸ“</div>
                        <h4>æ™ºèƒ½ä¸‹è½½</h4>
                        <p>è‡ªåŠ¨ä¿å­˜åˆ°videoæ–‡ä»¶å¤¹</p>
                    </div>
                </div>
            </div>

            <div class="upload-section">
                <div class="upload-area" id="uploadArea">
                    <div class="upload-icon">ğŸ¥</div>
                    <div class="upload-text">ç‚¹å‡»æˆ–æ‹–æ‹½è§†é¢‘æ–‡ä»¶åˆ°æ­¤å¤„</div>
                    <div class="upload-hint">
                        æ”¯æŒ MP4, MOV, WebM æ ¼å¼<br>
                        å»ºè®®æ–‡ä»¶å¤§å°ä¸è¶…è¿‡ 100MBï¼Œæ—¶é•¿ä¸è¶…è¿‡ 60 ç§’<br>
                        å¯åŒæ—¶å¤„ç†å¤šä¸ªæ–‡ä»¶
                    </div>
                    <div style="margin-top: 16px;">
                        <label class="btn" id="selectFileBtn" for="fileInput">
                            ğŸ“ é€‰æ‹©æ–‡ä»¶
                        </label>
                    </div>
                    <input type="file" class="file-input" id="fileInput" multiple accept=".mp4,.mov,.webm,video/mp4,video/quicktime,video/webm">
                </div>

                <div class="controls">
                    <button class="btn" onclick="alert('JavaScriptå·¥ä½œæ­£å¸¸ï¼')">
                        ğŸ§ª JSæµ‹è¯•
                    </button>
                    <button class="btn" id="settingsBtn" onclick="toggleSettings()">
                        âš™ï¸ é«˜çº§è®¾ç½®
                    </button>
                    <button class="btn secondary" onclick="runDiagnosticTest()">
                        ğŸ”§ ç³»ç»Ÿæµ‹è¯•
                    </button>
                    <button class="btn secondary" onclick="testUploadFunction()">
                        ğŸ” æµ‹è¯•ä¸Šä¼ 
                    </button>
                    <button class="btn" id="watchSourceBtn" style="background: linear-gradient(135deg, #17a2b8 0%, #20c997 100%);">
                        ğŸ“¡ ç›‘æ§ source ç›®å½•
                    </button>
                    <button class="btn" id="pickOutputBtn" style="background: linear-gradient(135deg, #ff7f50 0%, #ffb199 100%);">
                        ğŸ“ è®¾ç½®è¾“å‡ºç›®å½•(video)
                    </button>
                    <span id="watchStatusText" style="align-self:center; color:#155724; font-weight:600;"></span>
                </div>

                <div class="settings-panel" id="settingsPanel">
                    <h3>âš™ï¸ è½¬æ¢å‚æ•°è®¾ç½®</h3>
                    
                    <div class="setting-group">
                        <label for="colorPicker">èƒŒæ™¯é¢œè‰²ï¼š</label>
                        <div class="color-picker-wrapper">
                            <input type="color" id="colorPicker" class="color-picker" value="#000000">
                            <span id="colorValue">#000000</span>
                        </div>
                        <small style="color: #666;">é€‰æ‹©è¦ç§»é™¤çš„èƒŒæ™¯é¢œè‰²ï¼ˆé»˜è®¤ä¸ºé»‘è‰²ï¼‰</small>
                    </div>

                    <div class="setting-group">
                        <label for="toleranceSlider">å®¹å·®ï¼š<span id="toleranceValue">50</span></label>
                        <input type="range" id="toleranceSlider" class="slider" min="0" max="100" value="50">
                        <small style="color: #666;">è°ƒæ•´é¢œè‰²åŒ¹é…çš„çµæ•åº¦ï¼Œå€¼è¶Šå¤§åŒ¹é…èŒƒå›´è¶Šå¹¿</small>
                    </div>

                    <div class="setting-group">
                        <label for="featherSlider">è¾¹ç¼˜å¹³æ»‘ï¼š<span id="featherValue">3</span></label>
                        <input type="range" id="featherSlider" class="slider" min="0" max="10" value="3">
                        <small style="color: #666;">è°ƒæ•´æŠ åƒåè¾¹ç¼˜çš„æŸ”åŒ–ç¨‹åº¦</small>
                    </div>
                    <div class="setting-group">
                        <label>
                            <input type="checkbox" id="wmEnabled" checked>
                            å»é™¤å·¦ä¸Šè§’æ°´å°
                        </label>
                        <small style="color: #666;">é»˜è®¤åŒºåŸŸ x=0.8%ã€y=0.8%ã€w=16%ã€h=6.5%</small>
                    </div>
                    <div class="setting-group" id="wmFields">
                        <label>æ°´å°åŒºåŸŸï¼ˆç™¾åˆ†æ¯” %ï¼‰</label>
                        <div style="display:flex; gap:12px; flex-wrap:wrap; align-items:flex-end;">
                            <div>
                                <label for="wmX">X%</label>
                                <input type="number" id="wmX" value="0.8" min="0" max="100" step="0.1" style="width: 90px; padding:6px;">
                            </div>
                            <div>
                                <label for="wmY">Y%</label>
                                <input type="number" id="wmY" value="0.8" min="0" max="100" step="0.1" style="width: 90px; padding:6px;">
                            </div>
                            <div>
                                <label for="wmW">W%</label>
                                <input type="number" id="wmW" value="16.0" min="0.1" max="100" step="0.1" style="width: 90px; padding:6px;">
                            </div>
                            <div>
                                <label for="wmH">H%</label>
                                <input type="number" id="wmH" value="6.5" min="0.1" max="100" step="0.1" style="width: 90px; padding:6px;">
                            </div>
                        </div>
                        <label for="wmFeather">æ°´å°ç¾½åŒ–(px)ï¼š<span id="wmFeatherValue">1.5</span></label>
                        <input type="range" id="wmFeather" class="slider" min="0" max="8" step="0.5" value="1.5">
                        <small style="color: #666;">åŠ å¤§å¯å‡å¼±è¾¹ç•Œç—•è¿¹ï¼›ä¸º0åˆ™é”åˆ©åˆ‡é™¤</small>
                    </div>
                    <div class="setting-group">
                        <button class="btn" id="roiPickBtn" style="padding:10px 16px; min-width:auto;">
                            ğŸ–±ï¸ æ¡†é€‰åŒºåŸŸ
                        </button>
                    </div>
                </div>
            </div>

            <div class="file-list hidden" id="fileList">
                <h3>ğŸ“‹ æ–‡ä»¶åˆ—è¡¨</h3>
                <div style="background: #e8f5e8; border: 1px solid #c3e6c3; border-radius: 8px; padding: 12px; margin-bottom: 16px; font-size: 0.9rem; color: #2d5a2d;">
                    <strong>ğŸ’¡ ä¸‹è½½è¯´æ˜ï¼š</strong><br>
                    â€¢ æ™®é€šä¸‹è½½ï¼šä¿æŒåŸæ–‡ä»¶å<br>
                    â€¢ ä¸‹è½½åˆ°videoæ–‡ä»¶å¤¹ï¼šé‡å‘½åä¸º 1.webm, 2.webm ... (æœ€å¤š200ä¸ª)<br>
                    â€¢ æ‰¹é‡ä¸‹è½½åˆ°videoæ–‡ä»¶å¤¹ï¼šä»åºå·1å¼€å§‹ä¾æ¬¡å‘½å<br>
                    â€¢ å¯ç‚¹å‡»"é‡ç½®åºå·"æŒ‰é’®é‡æ–°ä»1å¼€å§‹è®¡æ•°
                </div>
                <div id="filesContainer"></div>
                
                <div class="controls">
                    <button class="btn" id="convertAllBtn" onclick="convertAllFiles()">
                        ğŸš€ å¼€å§‹è½¬æ¢
                    </button>
                    <button class="btn secondary" onclick="downloadAll()">
                        ğŸ“¦ æ‰¹é‡ä¸‹è½½
                    </button>
                    <button class="btn" onclick="downloadAllToFolder()" style="background: linear-gradient(135deg, #28a745 0%, #20c997 100%);">
                        ğŸ“ ä¸‹è½½åˆ°videoæ–‡ä»¶å¤¹
                    </button>
                    <button class="btn secondary" onclick="resetDownloadCounter(); showToast('ä¸‹è½½åºå·å·²é‡ç½®ä¸º1', 'success');" title="é‡ç½®ä¸‹è½½åºå·ä»1å¼€å§‹">
                        ğŸ”„ é‡ç½®åºå·
                    </button>
                    <button class="btn danger" onclick="clearAllFiles()">
                        ğŸ—‘ï¸ æ¸…ç©ºæ‰€æœ‰
                    </button>
                </div>
            </div>
        </div>
    </div>

    <!-- Toast é€šçŸ¥ -->
    <div class="toast" id="toast"></div>

    <!-- åŠ è½½è¦†ç›–å±‚ -->
    <div class="loading-overlay" id="loadingOverlay">
        <div>
            <div class="loading-spinner"></div>
            <p style="color: white; margin-top: 16px; text-align: center;">æ­£åœ¨å¤„ç†è§†é¢‘...</p>
        </div>
    </div>

    <script>
        // å°è¯•æ³¨å†Œ COOP/COEP Service Workerï¼Œå¯ç”¨ crossOriginIsolated ä»¥ä½¿ç”¨ SharedArrayBuffer
        (function registerCOISW(){
            // file:// ä¸‹ SW ä¼šæŠ¥é”™ï¼Œç›´æ¥åæ‰
            if (!('serviceWorker' in navigator)) return;
            try { navigator.serviceWorker.register('./coi-serviceworker.js'); } catch (_) {}
        })();
        // å…¨å±€å˜é‡
        let selectedFiles = [];
        let processedFiles = new Map();
        let currentSettings = {
            color: '#000000',
            tolerance: 50,
            feather: 3,
            wmEnabled: true,
            wmX: 0.8,
            wmY: 0.8,
            wmW: 16.0,
            wmH: 6.5,
            wmFeather: 1.5
        };

        // wasm/Worker FFmpeg æ”¯æŒ
        let ffmpegWorker = null;
        let ffmpegReady = false;
        let currentPipeline = 'auto'; // 'wasm' | 'canvas' | 'auto'
        async function ensureFfmpegWorker() {
            if (ffmpegWorker) return ffmpegWorker;
            try {
                ffmpegWorker = new Worker('./ffmpeg-worker.js');
                // æ¢æµ‹
                ffmpegReady = await new Promise((resolve) => {
                    const onMsg = (ev) => {
                        const d = ev.data || {};
                        if (d.type === 'probe:ok') {
                            ffmpegWorker.removeEventListener('message', onMsg);
                            resolve(true);
                        } else if (d.type === 'error') {
                            ffmpegWorker.removeEventListener('message', onMsg);
                            resolve(false);
                        }
                    };
                    ffmpegWorker.addEventListener('message', onMsg);
                    ffmpegWorker.postMessage({ type: 'probe' });
                    setTimeout(() => { ffmpegWorker.removeEventListener('message', onMsg); resolve(false); }, 30000);
                });
                if (!ffmpegReady) {
                    try { ffmpegWorker.terminate(); } catch (_) {}
                    ffmpegWorker = null;
                }
            } catch (_) {
                ffmpegWorker = null;
                ffmpegReady = false;
            }
            return ffmpegWorker;
        }

        // æ–¹æ¡ˆäºŒï¼šå†…è” Web Worker + å¯è§æ€§é™é¢‘
        let pixelWorker = null;
        let workerBusy = false;
        let pageHidden = false;
        let __visibleWaitResolvers = [];
        function waitForVisible() {
            if (!pageHidden) return Promise.resolve();
            return new Promise(function(resolve){ __visibleWaitResolvers.push(resolve); });
        }
        let __bgToastShown = false;
        document.addEventListener('visibilitychange', function() {
            pageHidden = document.hidden;
            if (currentPipeline === 'wasm') {
                // wasm ç®¡çº¿åœ¨åå°ç»§ç»­å¤„ç†ï¼Œä»…æç¤º UI è¿›åº¦å¯èƒ½å»¶è¿Ÿ
                if (pageHidden && !__bgToastShown) {
                    try { showToast('åå°å¤„ç†ä¸­ï¼ˆUIè¿›åº¦å¯èƒ½å»¶è¿Ÿï¼‰', 'info'); } catch (_) {}
                    __bgToastShown = true;
                }
                if (!pageHidden && __bgToastShown) { __bgToastShown = false; }
            } else {
                if (pageHidden) {
                    if (!__bgToastShown) {
                        try { showToast('åå°æš‚åœå¤„ç†ä¸­ï¼Œåˆ‡å›å‰å°ç»§ç»­', 'warning'); } catch (_) {}
                        __bgToastShown = true;
                    }
                } else {
                    if (__bgToastShown) {
                        try { showToast('å·²æ¢å¤å¤„ç†', 'success'); } catch (_) {}
                        __bgToastShown = false;
                    }
                }
            }
            if (!pageHidden && __visibleWaitResolvers.length > 0) {
                const pending = __visibleWaitResolvers.slice();
                __visibleWaitResolvers.length = 0;
                pending.forEach(function(fn){ try { fn(); } catch (_) {} });
            }
        });

        // ç›‘æ§ source ç›®å½•ç›¸å…³
        let sourceDirHandle = null;
        let watchTimer = null;
        let isWatching = false;
        let watchIntervalMs = 3000; // è‡ªé€‚åº”åŒºé—´ï¼šå‰å° 3sï¼Œåå°æ”¾ç¼“
        const maxPickPerScan = 5; // å•è½®æœ€å¤šæ‹¾å–æ–‡ä»¶æ•°ï¼Œé¿å…å †ç§¯
        const uploadedFingerprintSet = new Set(); // å†…å­˜å»é‡
        const uploadedFingerprintKey = 'alphavid_uploaded_fingerprints_v1'; // æœ¬åœ°æŒä¹…åŒ–
        const pendingStableMap = new Map(); // è·Ÿè¸ªå¾…ç¨³å®šæ–‡ä»¶ {key -> {size, seenCount}}

        // ä» localStorage æ¢å¤å·²ä¸Šä¼ æŒ‡çº¹
        function restoreUploadedFingerprints() {
            try {
                const raw = localStorage.getItem(uploadedFingerprintKey);
                if (raw) {
                    const arr = JSON.parse(raw);
                    if (Array.isArray(arr)) arr.forEach(k => uploadedFingerprintSet.add(k));
                }
            } catch (_) {}
        }

        function persistUploadedFingerprints() {
            try {
                const arr = Array.from(uploadedFingerprintSet);
                localStorage.setItem(uploadedFingerprintKey, JSON.stringify(arr));
            } catch (_) {}
        }

        function updateWatchStatus(msg) {
            const el = document.getElementById('watchStatusText');
            if (el) el.textContent = msg || '';
        }

        function makeFileKey(name, size, mtime) {
            return `${name}__${size}__${mtime}`;
        }

        async function pickSourceDirectory() {
            if (!window.showDirectoryPicker) {
                showToast('å½“å‰æµè§ˆå™¨ä¸æ”¯æŒç›®å½•è®¿é—®ï¼Œæ— æ³•å¼€å¯ç›‘æ§', 'error');
                return null;
            }
            try {
                const handle = await window.showDirectoryPicker({ id: 'alphavid-source', mode: 'read' });
                sourceDirHandle = handle;
                showToast('å·²é€‰æ‹© source ç›®å½•', 'success');
                return handle;
            } catch (e) {
                showToast('æœªé€‰æ‹© source ç›®å½•', 'warning');
                return null;
            }
        }

        async function scanSourceOnce() {
            if (!sourceDirHandle) return;
            try {
                const newFiles = [];
                let picked = 0;
                for await (const [name, handle] of sourceDirHandle.entries()) {
                    if (handle.kind !== 'file') continue;
                    if (!name.toLowerCase().endsWith('.mp4')) continue;
                    // è¯»å–å…ƒä¿¡æ¯
                    const file = await handle.getFile();
                    const key = makeFileKey(name, file.size, file.lastModified);
                    // å·²å¤„ç†è¿‡è·³è¿‡
                    if (uploadedFingerprintSet.has(key)) continue;

                    // ç¨³å®šæ€§åˆ¤æ–­ï¼šåŒæ ·çš„ name å¦‚æœ size è¿ç»­ >=2 æ¬¡ä¸€è‡´æ‰è®¤å®šç¨³å®š
                    const prev = pendingStableMap.get(name);
                    if (prev && prev.size === file.size) {
                        prev.seen = (prev.seen || 1) + 1;
                    } else {
                        pendingStableMap.set(name, { size: file.size, seen: 1 });
                    }
                    const curr = pendingStableMap.get(name);
                    if (curr.seen < 2) continue; // æœªç¨³å®š

                    newFiles.push(file);
                    picked++;
                    if (picked >= maxPickPerScan) break;
                }

                if (newFiles.length > 0) {
                    // å…¥é˜Ÿä¸Šä¼ 
                    processFileSelection(newFiles);
                    // æ ‡è®°æŒ‡çº¹ï¼ˆä½¿ç”¨æœ¬æ¬¡æ–‡ä»¶çš„å…ƒä¿¡æ¯ï¼‰
                    newFiles.forEach(f => {
                        const k = makeFileKey(f.name, f.size, f.lastModified);
                        uploadedFingerprintSet.add(k);
                    });
                    persistUploadedFingerprints();
                    updateWatchStatus(`å·²å‘ç°å¹¶åŠ å…¥ ${newFiles.length} ä¸ªæ–°æ–‡ä»¶`);
                    // è‡ªåŠ¨è§¦å‘è½¬æ¢ï¼ˆè‹¥æœ‰æœªå®Œæˆï¼‰
                    autoConvertIfNeeded();
                } else {
                    updateWatchStatus('ç›‘æ§ä¸­â€¦ æœªå‘ç°æ–°æ–‡ä»¶');
                }
            } catch (e) {
                console.warn('æ‰«æ source ç›®å½•å¤±è´¥:', e);
                updateWatchStatus('æ‰«æå¤±è´¥ï¼Œç­‰å¾…é‡è¯•â€¦');
            }
        }

        function startWatchingSource() {
            if (!sourceDirHandle) return;
            if (isWatching) return;
            isWatching = true;
            updateWatchStatus('ç›‘æ§ä¸­â€¦');
            const tick = async () => {
                if (!isWatching) return;
                await scanSourceOnce();
                const delay = pageHidden ? Math.min(10000, watchIntervalMs * 2) : watchIntervalMs;
                watchTimer = setTimeout(tick, delay);
            };
            tick();
        }

        function stopWatchingSource() {
            isWatching = false;
            if (watchTimer) clearTimeout(watchTimer);
            watchTimer = null;
            updateWatchStatus('å·²åœæ­¢ç›‘æ§');
        }

        // è‡ªåŠ¨è§¦å‘è½¬æ¢ä¸ä¸‹è½½
        let autoConvertPending = false;
        let autoDownloadLocked = false;
        function resetAutoDownloadLock() { autoDownloadLocked = false; }
        const immediatePerFileSave = true; // æ¯ä¸ªæ–‡ä»¶å®Œæˆåç«‹å³ä¿å­˜
        function autoConvertIfNeeded() {
            if (autoConvertPending) return;
            autoConvertPending = true;
            setTimeout(async () => {
                try {
                    // è‹¥å­˜åœ¨æœªå¤„ç†æˆåŠŸçš„æ–‡ä»¶ï¼Œåˆ™è§¦å‘ä¸€æ¬¡æ‰¹é‡è½¬æ¢
                    const need = selectedFiles.filter(f => {
                        const pf = processedFiles.get(f.name);
                        return !pf || pf.status !== 'success';
                    });
                    if (need.length > 0) {
                        await convertAllFiles();
                    }

                    // æ£€æŸ¥å…¨éƒ¨æ˜¯å¦æˆåŠŸï¼Œå¦‚æ˜¯åˆ™è‡ªåŠ¨ä¸‹è½½
                    const allDone = selectedFiles.length > 0 && selectedFiles.every(f => {
                        const pf = processedFiles.get(f.name);
                        return pf && pf.status === 'success';
                    });
                    // è‹¥å¯ç”¨é€ä¸ªä¿å­˜ï¼Œåˆ™è·³è¿‡â€œå…¨éƒ¨å®Œæˆåæ‰¹é‡ä¸‹è½½â€çš„é€»è¾‘
                    if (!immediatePerFileSave) {
                        if (allDone && !autoDownloadLocked) {
                            if (!outputDirHandle) {
                                showToast('è¯·å…ˆç‚¹å‡»â€œè®¾ç½®è¾“å‡ºç›®å½•(video)â€', 'warning');
                            } else {
                                await downloadAllToFolder();
                                autoDownloadLocked = true;
                            }
                        }
                    }
                } finally {
                    autoConvertPending = false;
                }
            }, 500);
        }

        function toggleWatch() {
            const btn = document.getElementById('watchSourceBtn');
            if (!isWatching) {
                // å¼€å¯
                pickSourceDirectory().then(handle => {
                    if (!handle) return;
                    restoreUploadedFingerprints();
                    startWatchingSource();
                    if (btn) btn.textContent = 'â¸ åœæ­¢ç›‘æ§';
                });
            } else {
                stopWatchingSource();
                if (btn) btn.textContent = 'ğŸ“¡ ç›‘æ§ source ç›®å½•';
            }
        }

        function ensurePixelWorker() {
            if (pixelWorker) return pixelWorker;
            const workerCode = `
                function hexToRgb(hex){
                    const r = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
                    return r ? { r: parseInt(r[1],16), g: parseInt(r[2],16), b: parseInt(r[3],16) } : { r:0,g:0,b:0 };
                }
                self.onmessage = function(e){
                    const { type, payload } = e.data || {}; 
                    if (type === 'process') {
                        try {
                            const { buffer, width, height, color, tolerance255, feather } = payload;
                            const data = new Uint8ClampedArray(buffer);
                            const tgt = hexToRgb(color);
                            const tol = tolerance255;
                            const featherRange = feather * 10;
                            for (let i = 0; i < data.length; i += 4) {
                                const r = data[i], g = data[i+1], b = data[i+2];
                                const diff = Math.sqrt(
                                    Math.pow(r - tgt.r, 2) +
                                    Math.pow(g - tgt.g, 2) +
                                    Math.pow(b - tgt.b, 2)
                                );
                                if (diff <= tol) {
                                    let alpha = 0;
                                    if (feather > 0) {
                                        if (diff > tol - featherRange) {
                                            alpha = (diff - (tol - featherRange)) / featherRange;
                                        }
                                    }
                                    data[i+3] = Math.floor(alpha * 255);
                                }
                            }
                            self.postMessage({ type:'done', buffer: data.buffer, width, height }, [data.buffer]);
                        } catch (err) {
                            self.postMessage({ type:'error', message: err && err.message ? err.message : 'unknown' });
                        }
                    }
                };
            `;
            const blob = new Blob([workerCode], { type: 'application/javascript' });
            const url = URL.createObjectURL(blob);
            pixelWorker = new Worker(url);
            URL.revokeObjectURL(url);
            return pixelWorker;
        }

        function processFrameInWorker(imageData) {
            return new Promise((resolve, reject) => {
                try {
                    ensurePixelWorker();
                    if (!pixelWorker) {
                        reject(new Error('Worker åˆå§‹åŒ–å¤±è´¥'));
                        return;
                    }
                    const payload = {
                        buffer: imageData.data.buffer,
                        width: imageData.width,
                        height: imageData.height,
                        color: currentSettings.color,
                        tolerance255: currentSettings.tolerance / 100 * 255,
                        feather: currentSettings.feather || 0
                    };
                    workerBusy = true;
                    const onMessage = function(ev){
                        const d = ev.data || {};
                        if (d.type === 'done') {
                            pixelWorker.removeEventListener('message', onMessage);
                            workerBusy = false;
                            const out = new ImageData(new Uint8ClampedArray(d.buffer), d.width, d.height);
                            resolve(out);
                        } else if (d.type === 'error') {
                            pixelWorker.removeEventListener('message', onMessage);
                            workerBusy = false;
                            reject(new Error(d.message || 'Worker å¤„ç†å¤±è´¥'));
                        }
                    };
                    pixelWorker.addEventListener('message', onMessage);
                    pixelWorker.postMessage({ type:'process', payload }, [payload.buffer]);
                } catch (e) {
                    reject(e);
                }
            });
        }

        // æµ‹è¯•JavaScriptæ˜¯å¦æ­£å¸¸å·¥ä½œ
        function testJavaScript() {
            alert('JavaScriptæ­£å¸¸å·¥ä½œï¼');
            console.log('JavaScriptæµ‹è¯•é€šè¿‡');
        }

        // ç«‹å³æ‰§è¡Œçš„æµ‹è¯•
        console.log('è„šæœ¬å¼€å§‹åŠ è½½...');
        
        // ç¡®ä¿åŸºæœ¬åŠŸèƒ½å¯ç”¨
        window.testJS = function() {
            alert('å…¨å±€å‡½æ•°å¯ç”¨ï¼');
        };

        // åˆå§‹åŒ–
        document.addEventListener('DOMContentLoaded', function() {
            console.log('DOMåŠ è½½å®Œæˆï¼Œå¼€å§‹åˆå§‹åŒ–...');
            
            try {
                initializeEventListeners();
                console.log('äº‹ä»¶ç›‘å¬å™¨åˆå§‹åŒ–å®Œæˆ');
                
                initializeSettings();
                console.log('è®¾ç½®åˆå§‹åŒ–å®Œæˆ');
                
                checkBrowserSupport();
                console.log('æµè§ˆå™¨æ”¯æŒæ£€æŸ¥å®Œæˆ');
                
                console.log('æ‰€æœ‰åˆå§‹åŒ–å®Œæˆ');
            } catch (error) {
                console.error('åˆå§‹åŒ–è¿‡ç¨‹ä¸­å‡ºç°é”™è¯¯:', error);
                alert('é¡µé¢åˆå§‹åŒ–å¤±è´¥: ' + error.message);
            }
        });

        // æ£€æŸ¥æµè§ˆå™¨æ”¯æŒ
        function checkBrowserSupport() {
            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            if (!ctx || !window.URL || !window.URL.createObjectURL) {
                showToast('æ‚¨çš„æµè§ˆå™¨ç‰ˆæœ¬è¿‡ä½ï¼Œè¯·ä½¿ç”¨ç°ä»£æµè§ˆå™¨', 'error');
                return false;
            }
            
            // æ£€æŸ¥ MediaRecorder æ”¯æŒ
            if (!window.MediaRecorder) {
                showToast('æµè§ˆå™¨ä¸æ”¯æŒè§†é¢‘å½•åˆ¶åŠŸèƒ½', 'error');
                return false;
            }
            
            // æ£€æŸ¥æ”¯æŒçš„è§†é¢‘æ ¼å¼
            const supportedFormats = [];
            const testFormats = [
                'video/webm;codecs=vp9',
                'video/webm;codecs=vp8', 
                'video/webm',
                'video/mp4;codecs=h264'
            ];
            
            testFormats.forEach(format => {
                if (MediaRecorder.isTypeSupported(format)) {
                    supportedFormats.push(format);
                }
            });
            
            console.log('æ”¯æŒçš„è§†é¢‘æ ¼å¼:', supportedFormats);
            
            if (supportedFormats.length === 0) {
                showToast('æµè§ˆå™¨ä¸æ”¯æŒæ‰€éœ€çš„è§†é¢‘æ ¼å¼', 'error');
                return false;
            }
            
            // æ˜¾ç¤ºæµè§ˆå™¨ä¿¡æ¯
            console.log('æµè§ˆå™¨ä¿¡æ¯:', {
                userAgent: navigator.userAgent,
                supportedFormats: supportedFormats,
                canvasSupport: !!ctx,
                mediaRecorderSupport: !!window.MediaRecorder
            });
            
            return true;
        }

        // è§¦å‘æ–‡ä»¶é€‰æ‹©çš„ç»Ÿä¸€å‡½æ•°
        function triggerFileSelection() {
            const fileInput = document.getElementById('fileInput');
            if (!fileInput) {
                console.error('File input not found');
                showToast('æ–‡ä»¶è¾“å…¥å…ƒç´ æœªæ‰¾åˆ°', 'error');
                return;
            }
            
            try {
                // ä¼˜å…ˆå°è¯•ç°ä»£APIï¼šshowPickerï¼ˆæ›´ç¨³å®šï¼Œéœ€å®‰å…¨ä¸Šä¸‹æ–‡ï¼‰
                if (typeof fileInput.showPicker === 'function') {
                    fileInput.showPicker();
                    console.log('æ–‡ä»¶å¯¹è¯æ¡†è§¦å‘æ–¹å¼0: showPicker');
                    return;
                }
                // æ–¹æ³•1: ç›´æ¥ç‚¹å‡»
                fileInput.click();
                console.log('æ–‡ä»¶å¯¹è¯æ¡†è§¦å‘æ–¹å¼1: ç›´æ¥ç‚¹å‡»');
            } catch (error1) {
                console.warn('æ–¹å¼1å¤±è´¥:', error1);
                
                try {
                    // æ–¹æ³•2: åˆ›å»ºç‚¹å‡»äº‹ä»¶
                    const clickEvent = new MouseEvent('click', {
                        bubbles: true,
                        cancelable: true,
                        view: window
                    });
                    fileInput.dispatchEvent(clickEvent);
                    console.log('æ–‡ä»¶å¯¹è¯æ¡†è§¦å‘æ–¹å¼2: äº‹ä»¶åˆ†å‘');
                } catch (error2) {
                    console.warn('æ–¹å¼2å¤±è´¥:', error2);
                    
                    try {
                        // æ–¹æ³•3: ç„¦ç‚¹åç‚¹å‡»
                        fileInput.focus();
                        fileInput.click();
                        console.log('æ–‡ä»¶å¯¹è¯æ¡†è§¦å‘æ–¹å¼3: ç„¦ç‚¹åç‚¹å‡»');
                    } catch (error3) {
                        console.error('æ‰€æœ‰æ–¹å¼éƒ½å¤±è´¥:', error3);
                        showToast('æ— æ³•æ‰“å¼€æ–‡ä»¶é€‰æ‹©å¯¹è¯æ¡†ï¼Œè¯·å°è¯•åˆ·æ–°é¡µé¢', 'error');
                    }
                }
            }
        }

        // åˆå§‹åŒ–äº‹ä»¶ç›‘å¬å™¨
        function initializeEventListeners() {
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');
            const watchBtn = document.getElementById('watchSourceBtn');
            const pickOutputBtn = document.getElementById('pickOutputBtn');
            const roiPickBtn = document.getElementById('roiPickBtn');

            if (!uploadArea || !fileInput) {
                console.error('Upload area or file input not found');
                return;
            }

            // ä¸Šä¼ åŒºåŸŸç‚¹å‡»äº‹ä»¶ - ä¿®å¤äº‹ä»¶å†²çªé—®é¢˜ï¼ˆä½¿ç”¨å†’æ³¡é˜¶æ®µï¼‰
            uploadArea.addEventListener('click', function(e) {
                // æ£€æŸ¥ç‚¹å‡»çš„æ˜¯å¦ä¸ºæŒ‰é’®æˆ–å…¶å­å…ƒç´ 
                if (
                    e.target && (
                        e.target.tagName === 'BUTTON' ||
                        (e.target.closest && e.target.closest('button')) ||
                        e.target.tagName === 'LABEL' ||
                        (e.target.closest && e.target.closest('label'))
                    )
                ) {
                    // å¦‚æœç‚¹å‡»çš„æ˜¯æŒ‰é’®ï¼Œä¸é˜»æ­¢é»˜è®¤è¡Œä¸ºï¼Œè®©æŒ‰é’®æ­£å¸¸å·¥ä½œ
                    console.log('Button clicked, allowing default behavior');
                    return;
                }
                
                // åªæœ‰ç‚¹å‡»ä¸Šä¼ åŒºåŸŸå…¶ä»–éƒ¨åˆ†æ—¶æ‰é˜»æ­¢é»˜è®¤è¡Œä¸ºå¹¶è§¦å‘æ–‡ä»¶é€‰æ‹©
                e.preventDefault();
                e.stopPropagation();
                console.log('Upload area clicked (not button)');
                
                // è§¦å‘æ–‡ä»¶é€‰æ‹©
                triggerFileSelection();
            }, false);

            // å¤‡ç”¨ç‚¹å‡»äº‹ä»¶ï¼ˆmousedownä¸å†é˜»æ–­æŒ‰é’®è¡Œä¸ºï¼Œé¿å…ç³»ç»Ÿé»˜è®¤è¢«æ‹¦æˆªï¼‰
            uploadArea.addEventListener('mousedown', function(e) {
                if (e.button === 0) {
                    // ç‚¹å‡»ä¸Šä¼ åŒºåŸŸç©ºç™½æ—¶ï¼Œå…è®¸åç»­clickè§¦å‘ç»Ÿä¸€é€»è¾‘
                    // ä¸åœ¨æ­¤å¤„é˜»æ­¢é»˜è®¤ï¼Œé¿å…æŸäº›æµè§ˆå™¨é˜»æ­¢file inputå¼¹çª—
                    if (e.target && (e.target.tagName === 'BUTTON' || (e.target.closest && e.target.closest('button')))) {
                        return;
                    }
                }
            });

            // æ‹–æ‹½äº‹ä»¶
            uploadArea.addEventListener('dragover', handleDragOver);
            uploadArea.addEventListener('dragenter', handleDragOver);
            uploadArea.addEventListener('dragleave', handleDragLeave);
            uploadArea.addEventListener('drop', handleDrop);

            // é˜»æ­¢å…¨å±€æ‹–æ‹½
            document.addEventListener('dragover', function(e) {
                e.preventDefault();
            });
            document.addEventListener('drop', function(e) {
                e.preventDefault();
            });

            // æ–‡ä»¶é€‰æ‹©
            fileInput.addEventListener('change', handleFileSelect);

            // é€‰æ‹©æ–‡ä»¶æŒ‰é’®ç‚¹å‡»äº‹ä»¶
            const selectFileBtn = document.getElementById('selectFileBtn');
            if (selectFileBtn) {
                selectFileBtn.addEventListener('click', function() {
                    console.log('Select file button clicked');
                    triggerFileSelection();
                });
            }

            if (watchBtn) {
                watchBtn.addEventListener('click', toggleWatch);
            }

            if (pickOutputBtn) {
                pickOutputBtn.addEventListener('click', () => ensureOutputDirectory(true));
            }

            if (roiPickBtn) {
                roiPickBtn.addEventListener('click', startRoiPicking);
            }

            console.log('Event listeners initialized successfully');
        }

        // ROI æ¡†é€‰äº¤äº’
        let roiPicking = false;
        let roiStart = null;
        let roiOverlay = null;
        function startRoiPicking() {
            if (roiPicking) return;
            // æ‰¾åˆ°ç¬¬ä¸€æ¡â€œé¢„è§ˆè§†é¢‘â€æˆ–åˆ›å»ºä¸€ä¸ªå¯è§†åŒ–ç”»å¸ƒ
            const anyPreview = document.querySelector('.preview-video');
            const host = anyPreview ? anyPreview.parentElement : document.querySelector('.upload-area');
            if (!host) { showToast('æ²¡æœ‰å¯ç”¨äºæ¡†é€‰çš„åŒºåŸŸï¼ˆè¯·å…ˆè½¬æ¢é¢„è§ˆï¼Œæˆ–ç‚¹å‡»ä¸Šä¼ åŒºåŸŸæ¡†é€‰ï¼‰', 'warning'); return; }
            const rect = host.getBoundingClientRect();

            // åˆ›å»ºè¦†ç›–å±‚
            roiOverlay = document.createElement('div');
            roiOverlay.style.position = 'fixed';
            roiOverlay.style.left = rect.left + 'px';
            roiOverlay.style.top = rect.top + 'px';
            roiOverlay.style.width = rect.width + 'px';
            roiOverlay.style.height = rect.height + 'px';
            roiOverlay.style.cursor = 'crosshair';
            roiOverlay.style.zIndex = '2500';
            roiOverlay.style.background = 'transparent';
            document.body.appendChild(roiOverlay);

            const box = document.createElement('div');
            box.style.position = 'absolute';
            box.style.border = '2px dashed #667eea';
            box.style.background = 'rgba(102,126,234,0.15)';
            box.style.pointerEvents = 'none';
            roiOverlay.appendChild(box);

            const toLocal = (clientX, clientY) => ({
                x: Math.max(0, Math.min(rect.width, clientX - rect.left)),
                y: Math.max(0, Math.min(rect.height, clientY - rect.top))
            });

            const onDown = (e) => {
                roiPicking = true;
                const p = toLocal(e.clientX, e.clientY);
                roiStart = p;
                box.style.left = p.x + 'px';
                box.style.top = p.y + 'px';
                box.style.width = '0px';
                box.style.height = '0px';
                e.preventDefault();
            };
            const onMove = (e) => {
                if (!roiPicking || !roiStart) return;
                const p = toLocal(e.clientX, e.clientY);
                const x = Math.min(roiStart.x, p.x);
                const y = Math.min(roiStart.y, p.y);
                const w = Math.abs(p.x - roiStart.x);
                const h = Math.abs(p.y - roiStart.y);
                box.style.left = x + 'px';
                box.style.top = y + 'px';
                box.style.width = w + 'px';
                box.style.height = h + 'px';
            };
            const finish = (p) => {
                roiPicking = false;
                // è®¡ç®—ç™¾åˆ†æ¯”å¹¶å†™å…¥è®¾ç½®
                const x = Math.min(roiStart.x, p.x);
                const y = Math.min(roiStart.y, p.y);
                const w = Math.abs(p.x - roiStart.x);
                const h = Math.abs(p.y - roiStart.y);
                if (w > 2 && h > 2) {
                    currentSettings.wmEnabled = true;
                    document.getElementById('wmEnabled').checked = true;
                    const xPct = (x / rect.width) * 100;
                    const yPct = (y / rect.height) * 100;
                    const wPct = (w / rect.width) * 100;
                    const hPct = (h / rect.height) * 100;
                    currentSettings.wmX = parseFloat(xPct.toFixed(1));
                    currentSettings.wmY = parseFloat(yPct.toFixed(1));
                    currentSettings.wmW = parseFloat(wPct.toFixed(1));
                    currentSettings.wmH = parseFloat(hPct.toFixed(1));
                    // åŒæ­¥è¾“å…¥æ¡†
                    document.getElementById('wmX').value = String(currentSettings.wmX);
                    document.getElementById('wmY').value = String(currentSettings.wmY);
                    document.getElementById('wmW').value = String(currentSettings.wmW);
                    document.getElementById('wmH').value = String(currentSettings.wmH);
                    showToast(`å·²è®¾ç½® ROI: x=${currentSettings.wmX}% y=${currentSettings.wmY}% w=${currentSettings.wmW}% h=${currentSettings.wmH}%`, 'success');
                }
                cleanup();
            };
            const onUp = (e) => {
                if (!roiPicking || !roiStart) return cleanup();
                const p = toLocal(e.clientX, e.clientY);
                finish(p);
            };
            const onKey = (e) => { if (e.key === 'Escape') cleanup(); };
            function cleanup(){
                roiPicking = false;
                roiStart = null;
                if (roiOverlay) { roiOverlay.remove(); roiOverlay = null; }
                window.removeEventListener('mousemove', onMove);
                window.removeEventListener('mouseup', onUp);
                window.removeEventListener('keydown', onKey);
            }

            roiOverlay.addEventListener('mousedown', onDown);
            window.addEventListener('mousemove', onMove);
            window.addEventListener('mouseup', onUp);
            window.addEventListener('keydown', onKey);
            showToast('æŒ‰ä¸‹åæ‹–æ‹½æ¡†é€‰å·¦ä¸Šè§’æ°´å°åŒºåŸŸï¼ŒEsc å–æ¶ˆ', 'info');
        }

        // åˆå§‹åŒ–è®¾ç½®
        function initializeSettings() {
            const colorPicker = document.getElementById('colorPicker');
            const toleranceSlider = document.getElementById('toleranceSlider');
            const featherSlider = document.getElementById('featherSlider');
            const wmEnabled = document.getElementById('wmEnabled');
            const wmX = document.getElementById('wmX');
            const wmY = document.getElementById('wmY');
            const wmW = document.getElementById('wmW');
            const wmH = document.getElementById('wmH');
            const wmFeather = document.getElementById('wmFeather');
            const wmFeatherValue = document.getElementById('wmFeatherValue');

            colorPicker.addEventListener('change', function() {
                currentSettings.color = this.value;
                document.getElementById('colorValue').textContent = this.value;
            });

            toleranceSlider.addEventListener('input', function() {
                currentSettings.tolerance = parseInt(this.value);
                document.getElementById('toleranceValue').textContent = this.value;
            });

            featherSlider.addEventListener('input', function() {
                currentSettings.feather = parseInt(this.value);
                document.getElementById('featherValue').textContent = this.value;
            });

            // å»æ°´å°è®¾ç½®
            wmEnabled.addEventListener('change', function() {
                currentSettings.wmEnabled = !!this.checked;
                document.getElementById('wmFields').style.opacity = this.checked ? '1' : '0.5';
            });
            const syncNum = (el, key) => el.addEventListener('input', function(){ currentSettings[key] = parseFloat(this.value || '0') || 0; });
            syncNum(wmX, 'wmX');
            syncNum(wmY, 'wmY');
            syncNum(wmW, 'wmW');
            syncNum(wmH, 'wmH');
            wmFeather.addEventListener('input', function(){ currentSettings.wmFeather = parseFloat(this.value || '0') || 0; wmFeatherValue.textContent = String(currentSettings.wmFeather); });

            // åˆå§‹åŒ–å€¼å±•ç¤º
            document.getElementById('colorValue').textContent = currentSettings.color;
            document.getElementById('toleranceValue').textContent = String(currentSettings.tolerance);
            document.getElementById('featherValue').textContent = String(currentSettings.feather);
            wmFeatherValue.textContent = String(currentSettings.wmFeather);
        }

        // æ‹–æ‹½å¤„ç†
        function handleDragOver(e) {
            e.preventDefault();
            e.stopPropagation();
            e.dataTransfer.dropEffect = 'copy';
            
            const uploadArea = e.currentTarget;
            uploadArea.classList.add('dragover');
            console.log('Drag over upload area');
        }

        function handleDragLeave(e) {
            e.preventDefault();
            e.stopPropagation();
            
            // åªæœ‰å½“ç¦»å¼€æ•´ä¸ªä¸Šä¼ åŒºåŸŸæ—¶æ‰ç§»é™¤æ ·å¼
            const uploadArea = e.currentTarget;
            const rect = uploadArea.getBoundingClientRect();
            const x = e.clientX;
            const y = e.clientY;
            
            if (x < rect.left || x > rect.right || y < rect.top || y > rect.bottom) {
                uploadArea.classList.remove('dragover');
                console.log('Drag leave upload area');
            }
        }

        function handleDrop(e) {
            e.preventDefault();
            e.stopPropagation();
            console.log('Files dropped');
            
            const uploadArea = e.currentTarget;
            uploadArea.classList.remove('dragover');
            
            const files = Array.from(e.dataTransfer.files);
            console.log(`Dropped ${files.length} files:`, files.map(f => f.name));
            
            if (files.length > 0) {
                processFileSelection(files);
            } else {
                showToast('æ²¡æœ‰æ£€æµ‹åˆ°æœ‰æ•ˆçš„æ–‡ä»¶', 'error');
            }
        }

        // æ–‡ä»¶é€‰æ‹©å¤„ç†
        function handleFileSelect(e) {
            console.log('File input changed');
            const files = Array.from(e.target.files);
            console.log(`Selected ${files.length} files:`, files.map(f => f.name));
            
            if (files.length > 0) {
                processFileSelection(files);
            } else {
                console.log('No files selected');
            }

            // å…³é”®ä¿®å¤ï¼šé‡ç½® input çš„å€¼ï¼Œä½¿å¾—å†æ¬¡é€‰æ‹©åŒä¸€ä¸ªæ–‡ä»¶ä¹Ÿä¼šè§¦å‘ change äº‹ä»¶
            try { e.target.value = ''; } catch (_) {}
        }

        // å¤„ç†æ–‡ä»¶é€‰æ‹©
        function processFileSelection(files) {
            console.log('å¼€å§‹å¤„ç†æ–‡ä»¶é€‰æ‹©:', files.length, 'ä¸ªæ–‡ä»¶');
            
            if (!files || files.length === 0) {
                showToast('æ²¡æœ‰é€‰æ‹©ä»»ä½•æ–‡ä»¶', 'error');
                return;
            }
            
            const validFiles = [];
            const errors = [];
            
            files.forEach(file => {
                console.log(`æ£€æŸ¥æ–‡ä»¶: ${file.name} (${formatFileSize(file.size)}, ${file.type})`);
                
                if (!isValidVideoFile(file)) {
                    const error = `${file.name}: ä¸æ”¯æŒçš„æ ¼å¼ (${file.type || 'æœªçŸ¥'})`;
                    errors.push(error);
                    console.warn(error);
                    return;
                }
                
                if (file.size > 100 * 1024 * 1024) {
                    const error = `${file.name}: æ–‡ä»¶è¿‡å¤§ (${formatFileSize(file.size)})`;
                    errors.push(error);
                    console.warn(error);
                    return;
                }
                
                if (file.size < 1024) {
                    const error = `${file.name}: æ–‡ä»¶å¤ªå°ï¼Œå¯èƒ½å·²æŸå`;
                    errors.push(error);
                    console.warn(error);
                    return;
                }
                
                // æ£€æŸ¥æ˜¯å¦å·²å­˜åœ¨
                const exists = selectedFiles.find(f => f.name === file.name && f.size === file.size);
                if (!exists) {
                    validFiles.push(file);
                    console.log(`æ–‡ä»¶ ${file.name} éªŒè¯é€šè¿‡`);
                } else {
                    console.log(`æ–‡ä»¶ ${file.name} å·²å­˜åœ¨ï¼Œè·³è¿‡`);
                }
            });
            
            // æ˜¾ç¤ºé”™è¯¯ä¿¡æ¯
            if (errors.length > 0) {
                errors.forEach(error => showToast(error, 'error'));
            }
            
            if (validFiles.length === 0) {
                if (errors.length === 0) {
                    showToast('æ‰€æœ‰æ–‡ä»¶éƒ½å·²å­˜åœ¨', 'info');
                } else {
                    showToast('æ²¡æœ‰æ‰¾åˆ°æœ‰æ•ˆçš„è§†é¢‘æ–‡ä»¶', 'error');
                }
                return;
            }

            selectedFiles = [...selectedFiles, ...validFiles];
            console.log(`æˆåŠŸæ·»åŠ  ${validFiles.length} ä¸ªæ–‡ä»¶ï¼Œå½“å‰æ€»æ•°: ${selectedFiles.length}`);
            displayFileList();
            showToast(`æˆåŠŸæ·»åŠ  ${validFiles.length} ä¸ªæ–‡ä»¶`, 'success');
            // æ–°å¢æ–‡ä»¶æ—¶ï¼Œå…è®¸æ–°çš„è‡ªåŠ¨ä¸‹è½½è§¦å‘
            resetAutoDownloadLock();
        }

        // éªŒè¯è§†é¢‘æ–‡ä»¶
        function isValidVideoFile(file) {
            const validTypes = [
                'video/mp4',
                'video/quicktime',
                'video/webm',
                'video/x-msvideo', // .avi
                'video/avi'
            ];
            
            // æ£€æŸ¥MIMEç±»å‹
            if (validTypes.includes(file.type)) {
                return true;
            }
            
            // å¦‚æœMIMEç±»å‹ä¸ºç©ºæˆ–æœªçŸ¥ï¼Œæ£€æŸ¥æ–‡ä»¶æ‰©å±•å
            const fileName = file.name.toLowerCase();
            const validExtensions = ['.mp4', '.mov', '.webm', '.avi'];
            
            return validExtensions.some(ext => fileName.endsWith(ext));
        }

        // æ˜¾ç¤ºæ–‡ä»¶åˆ—è¡¨
        function displayFileList() {
            const fileList = document.getElementById('fileList');
            const container = document.getElementById('filesContainer');

            if (selectedFiles.length === 0) {
                fileList.classList.add('hidden');
                return;
            }

            fileList.classList.remove('hidden');
            container.innerHTML = '';

            selectedFiles.forEach((file, index) => {
                const fileItem = createFileItem(file, index);
                container.appendChild(fileItem);
            });
        }

        // åˆ›å»ºæ–‡ä»¶é¡¹
        function createFileItem(file, index) {
            const item = document.createElement('div');
            item.className = 'file-item';
            item.id = `file-${index}`;

            const processedFile = processedFiles.get(file.name);
            const isProcessed = processedFile && processedFile.status === 'success';
            const isProcessing = processedFile && processedFile.status === 'processing';

            item.innerHTML = `
                <div class="file-header">
                    <div class="file-info">
                        <h4>${file.name}</h4>
                        <p>å¤§å°: ${formatFileSize(file.size)}</p>
                        <p>ç±»å‹: ${file.type}</p>
                    </div>
                    <div class="file-actions">
                        ${isProcessed ? `
                            <button class="btn btn-small" onclick="downloadFile(${index})">
                                ğŸ’¾ ä¸‹è½½
                            </button>
                            <button class="btn btn-small" onclick="downloadFileToFolder(${index})" style="background: linear-gradient(135deg, #28a745 0%, #20c997 100%); font-size: 0.8rem;">
                                ğŸ“ ä¸‹è½½åˆ°video/
                            </button>
                            <button class="btn btn-small" onclick="previewFile(${index})">
                                ğŸ‘€ é¢„è§ˆ
                            </button>
                        ` : `
                            <button class="btn btn-small" onclick="convertSingleFile(${index})">
                                ğŸ”„ è½¬æ¢
                            </button>
                        `}
                        <button class="btn btn-small danger" onclick="removeFile(${index})">
                            âŒ ç§»é™¤
                        </button>
                    </div>
                </div>
                <div class="status ${processedFile ? processedFile.status : 'pending'}" id="status-${index}">
                    ${getStatusText(processedFile ? processedFile.status : 'pending')}
                </div>
                <div class="progress-container ${isProcessing ? '' : 'hidden'}" id="progress-${index}">
                    <div class="progress-bar">
                        <div class="progress-fill" style="width: 0%"></div>
                    </div>
                    <div class="progress-text">
                        <div class="progress-percentage">0%</div>
                        <div class="progress-stage"></div>
                        <div class="progress-details"></div>
                    </div>
                </div>
                ${isProcessed ? `
                    <div class="preview-container">
                        <video class="preview-video" controls muted>
                            <source src="${processedFile.url}" type="video/webm">
                        </video>
                    </div>
                ` : ''}
            `;

            return item;
        }

        // è·å–çŠ¶æ€æ–‡æœ¬
        function getStatusText(status) {
            const statusMap = {
                'pending': 'â³ å¾…å¤„ç†',
                'processing': 'âš™ï¸ å¤„ç†ä¸­...',
                'success': 'âœ… å¤„ç†å®Œæˆ',
                'error': 'âŒ å¤„ç†å¤±è´¥'
            };
            return statusMap[status] || 'â“ æœªçŸ¥çŠ¶æ€';
        }

        // æ ¼å¼åŒ–æ–‡ä»¶å¤§å°
        function formatFileSize(bytes) {
            if (bytes === 0) return '0 B';
            const k = 1024;
            const sizes = ['B', 'KB', 'MB', 'GB'];
            const i = Math.floor(Math.log(bytes) / Math.log(k));
            return parseFloat((bytes / Math.pow(k, i)).toFixed(2)) + ' ' + sizes[i];
        }

        // åˆ‡æ¢è®¾ç½®é¢æ¿
        function toggleSettings() {
            const panel = document.getElementById('settingsPanel');
            const btn = document.getElementById('settingsBtn');
            
            if (panel.classList.contains('show')) {
                panel.classList.remove('show');
                btn.textContent = 'âš™ï¸ é«˜çº§è®¾ç½®';
            } else {
                panel.classList.add('show');
                btn.textContent = 'âš™ï¸ éšè—è®¾ç½®';
            }
        }

        // è½¬æ¢å•ä¸ªæ–‡ä»¶
        async function convertSingleFile(index) {
            const file = selectedFiles[index];
            if (!file) return;

            // ç«‹å³æ˜¾ç¤ºè¿›åº¦æ¡å’Œåˆå§‹çŠ¶æ€
            showProgress(index);
            updateFileStatus(index, 'processing', 'æ­£åœ¨åˆ†æè§†é¢‘...');
            updateProgress(index, 0, 'æ­£åœ¨åˆ†æè§†é¢‘...', 'å‡†å¤‡å¼€å§‹å¤„ç†è§†é¢‘æ–‡ä»¶');

            // è®°å½•å¤„ç†ä¸­çš„çŠ¶æ€ï¼Œé˜²æ­¢åˆ—è¡¨é‡ç»˜å›é€€ä¸º pending
            processedFiles.set(file.name, { status: 'processing', progress: 0 });

            try {
                // ä¼˜å…ˆå°è¯• wasm/ffmpeg ç®¡çº¿
                await ensureFfmpegWorker();
                let result;
                if (ffmpegWorker && ffmpegReady) {
                    updateProgress(index, 10, 'å‡†å¤‡ä½¿ç”¨ FFmpeg.wasm', 'åŠ è½½è§£ç /ç¼–ç å¼•æ“');
                    currentPipeline = 'wasm';
                    result = await processVideoFileWithFFmpeg(file, (progress, stage, details) => {
                        updateProgress(index, progress, stage, details);
                    });
                } else {
                    currentPipeline = 'canvas';
                    // å›é€€åˆ°åŸç”»å¸ƒ+MediaRecorder ç®¡çº¿
                    result = await processVideoFile(file, (progress, stage, details) => {
                        updateProgress(index, progress, stage, details);
                    });
                }

                processedFiles.set(file.name, {
                    status: 'success',
                    url: result.url,
                    blob: result.blob,
                    duration: result.duration,
                    frames: result.frames
                });

                updateFileStatus(index, 'success', 'å¤„ç†å®Œæˆ');
                hideProgress(index);
                addPreview(index, result.url);
                showToast(`${file.name} å¤„ç†å®Œæˆ (${result.frames} å¸§, ${result.duration.toFixed(1)}s)`, 'success');
                // åˆ·æ–°æŒ‰é’®ä¸º å•ä¸ªä¸‹è½½/é¢„è§ˆ/ç§»é™¤
                refreshFileActions(index);
                // æ¯ä¸ªæ–‡ä»¶æˆåŠŸåï¼šè‹¥å·²è®¾ç½®è¾“å‡ºç›®å½•åˆ™ç«‹åˆ»ä¿å­˜è¯¥æ–‡ä»¶
                try {
                    if (immediatePerFileSave) {
                        if (!outputDirHandle) {
                            showToast('è¯·å…ˆç‚¹å‡»â€œè®¾ç½®è¾“å‡ºç›®å½•(video)â€', 'warning');
                        } else {
                            await saveProcessedFileDirect(result.blob);
                        }
                    } else {
                        autoConvertIfNeeded();
                    }
                } catch (e) {
                    console.warn('å•æ–‡ä»¶è‡ªåŠ¨ä¿å­˜å¤±è´¥ï¼Œå°†åœ¨æ‰¹é‡é˜¶æ®µå¤„ç†:', e);
                }

            } catch (error) {
                console.error('å¤„ç†å¤±è´¥:', error);
                const errorMessage = error.message || 'æœªçŸ¥é”™è¯¯';
                processedFiles.set(file.name, { 
                    status: 'error', 
                    error: errorMessage,
                    fullError: error
                });
                updateFileStatus(index, 'error', 'å¤„ç†å¤±è´¥');
                hideProgress(index);
                currentPipeline = 'auto';
                
                // æ˜¾ç¤ºè¯¦ç»†é”™è¯¯ä¿¡æ¯
                addErrorDetails(index, errorMessage);
                showToast(`${file.name} å¤„ç†å¤±è´¥: ${errorMessage}`, 'error');
            }
        }

        // è½¬æ¢æ‰€æœ‰æ–‡ä»¶
        async function convertAllFiles() {
            if (selectedFiles.length === 0) {
                showToast('è¯·å…ˆé€‰æ‹©è¦è½¬æ¢çš„è§†é¢‘æ–‡ä»¶', 'warning');
                return;
            }

            const convertBtn = document.getElementById('convertAllBtn');
            convertBtn.disabled = true;
            convertBtn.textContent = 'ğŸ”„ è½¬æ¢ä¸­...';

            try {
                for (let i = 0; i < selectedFiles.length; i++) {
                    const processedFile = processedFiles.get(selectedFiles[i].name);
                    if (!processedFile || processedFile.status !== 'success') {
                        await convertSingleFile(i);
                        // æ·»åŠ å»¶è¿Ÿé¿å…æµè§ˆå™¨å¡é¡¿
                        await new Promise(resolve => setTimeout(resolve, 500));
                    }
                }
                showToast('æ‰€æœ‰æ–‡ä»¶å¤„ç†å®Œæˆ', 'success');
            } catch (error) {
                showToast('æ‰¹é‡è½¬æ¢å‡ºç°é”™è¯¯', 'error');
            } finally {
                convertBtn.disabled = false;
                convertBtn.textContent = 'ğŸš€ å¼€å§‹è½¬æ¢';
            }
        }

        // å¤„ç†è§†é¢‘æ–‡ä»¶çš„æ ¸å¿ƒå‡½æ•°
        async function processVideoFile(file, progressCallback) {
            return new Promise((resolve, reject) => {
                const video = document.createElement('video');
                const canvas = document.createElement('canvas');
                const ctx = canvas.getContext('2d');
                
                // è®¾ç½®è§†é¢‘å±æ€§
                video.crossOrigin = 'anonymous';
                video.muted = true;

                // é˜¶æ®µ1: åŠ è½½è§†é¢‘æ–‡ä»¶
                progressCallback(1, 'åŠ è½½è§†é¢‘æ–‡ä»¶', 'è§£æè§†é¢‘å…ƒæ•°æ®...');

                video.onloadedmetadata = function() {
                    console.log(`è§†é¢‘ä¿¡æ¯: ${video.videoWidth}x${video.videoHeight}, æ—¶é•¿: ${video.duration}s`);
                    
                    // é˜¶æ®µ2: éªŒè¯è§†é¢‘
                    progressCallback(5, 'éªŒè¯è§†é¢‘', 'æ£€æŸ¥è§†é¢‘æ ¼å¼å’Œå‚æ•°...');
                    
                    // æ£€æŸ¥è§†é¢‘å°ºå¯¸æ˜¯å¦æœ‰æ•ˆ
                    if (!video.videoWidth || !video.videoHeight || video.videoWidth === 0 || video.videoHeight === 0) {
                        reject(new Error(`è§†é¢‘å°ºå¯¸æ— æ•ˆ: ${video.videoWidth}x${video.videoHeight}ã€‚è¯·ç¡®ä¿è§†é¢‘æ–‡ä»¶å®Œæ•´ä¸”æ ¼å¼æ­£ç¡®ã€‚`));
                        return;
                    }
                    
                    if (!video.duration || video.duration === 0 || isNaN(video.duration)) {
                        reject(new Error(`è§†é¢‘æ—¶é•¿æ— æ•ˆ: ${video.duration}ã€‚è¯·ç¡®ä¿è§†é¢‘æ–‡ä»¶å®Œæ•´ã€‚`));
                        return;
                    }
                    
                    // é˜¶æ®µ3: é…ç½®ç”»å¸ƒ
                    progressCallback(10, 'é…ç½®ç”»å¸ƒ', 'è®¡ç®—æœ€ä½³å¤„ç†å°ºå¯¸...');
                    
                    // è®¾ç½®åˆé€‚çš„ç”»å¸ƒå°ºå¯¸
                    const maxSize = 720; // é™åˆ¶æœ€å¤§å°ºå¯¸ä»¥æé«˜æ€§èƒ½
                    let width = video.videoWidth;
                    let height = video.videoHeight;
                    
                    if (width > height) {
                        if (width > maxSize) {
                            height = (height * maxSize) / width;
                            width = maxSize;
                        }
                    } else {
                        if (height > maxSize) {
                            width = (width * maxSize) / height;
                            height = maxSize;
                        }
                    }
                    
                    // ç¡®ä¿å°ºå¯¸è‡³å°‘ä¸º1ä¸”ä¸ºæ•´æ•°
                    canvas.width = Math.max(1, Math.floor(width));
                    canvas.height = Math.max(1, Math.floor(height));
                    
                    console.log(`ç”»å¸ƒå°ºå¯¸è®¾ç½®ä¸º: ${canvas.width}x${canvas.height}`);
                    
                    // é˜¶æ®µ4: å‡†å¤‡å¤„ç†
                    progressCallback(15, 'å‡†å¤‡å¤„ç†', 'åˆå§‹åŒ–è§†é¢‘å¤„ç†å¼•æ“...');
                    
                    // ç­‰å¾…è§†é¢‘å®Œå…¨å‡†å¤‡å¥½
                    if (video.readyState >= 2) {
                        processFrames();
                    } else {
                        video.oncanplay = processFrames;
                    }
                };

                video.onerror = function(e) {
                    console.error('è§†é¢‘åŠ è½½é”™è¯¯:', e);
                    reject(new Error('è§†é¢‘æ–‡ä»¶åŠ è½½å¤±è´¥ï¼Œè¯·æ£€æŸ¥æ–‡ä»¶æ ¼å¼'));
                };

                let isProcessing = false;
                const frames = [];
                const targetFPS = 15; // ç›®æ ‡å¸§ç‡
                const frameInterval = 1000 / targetFPS; // å¸§é—´éš”(ms)
                let processingStartTime = performance.now();

                function processFrames() {
                    if (isProcessing) return;
                    isProcessing = true;

                    let currentFrame = 0;
                    const totalFrames = Math.floor(video.duration * targetFPS);
                    processingStartTime = performance.now(); // é‡ç½®å¼€å§‹æ—¶é—´
                    
                    console.log(`å¼€å§‹å¤„ç† ${totalFrames} å¸§`);
                    
                    // é˜¶æ®µ5: å¼€å§‹å¸§å¤„ç†
                    progressCallback(20, 'å¤„ç†è§†é¢‘å¸§', `å‡†å¤‡å¤„ç† ${totalFrames} å¸§...`);

                    async function processNextFrame() {
                        if (currentFrame >= totalFrames) {
                            console.log(`å¤„ç†å®Œæˆï¼Œå…± ${frames.length} å¸§`);
                            // é˜¶æ®µ6: ç”Ÿæˆè¾“å‡º
                            progressCallback(90, 'ç”Ÿæˆè§†é¢‘', 'æ­£åœ¨ç¼–ç è¾“å‡ºè§†é¢‘...');
                            generateOutput();
                            return;
                        }

                        // å¦‚æœåœ¨åå°ï¼Œåˆ™ç­‰å¾…åˆ‡å›å‰å°å†ç»§ç»­ï¼Œé¿å… seek/ç»˜åˆ¶/ç¼–ç å¤±è´¥
                        if (pageHidden) {
                            progressCallback(20 + (currentFrame / totalFrames) * 65, 'åå°æš‚åœ', 'åˆ‡å›å‰å°åç»§ç»­å¤„ç†');
                            try { await waitForVisible(); } catch (_) {}
                        }

                        const targetTime = currentFrame / targetFPS;

                        // onseeked å¯é æ€§å¢å¼ºï¼šè¶…æ—¶å›é€€é‡è¯•
                        let seeked = false;
                        const onSeekedOnce = function(){ seeked = true; video.onseeked = handleSeeked; };
                        const handleSeeked = video.onseeked; // existing handler set below
                        video.addEventListener('seeked', onSeekedOnce, { once: true });
                        video.currentTime = targetTime;
                        setTimeout(() => {
                            if (!seeked) {
                                console.warn('seekè¶…æ—¶ï¼Œé‡è¯•è®¾ç½®currentTime');
                                video.currentTime = Math.min(targetTime + (1/targetFPS), video.duration);
                            }
                        }, pageHidden ? 400 : 200);
                        
                        // æ³¨æ„ï¼šå®é™…çš„è¿›åº¦æ›´æ–°ç°åœ¨ç§»åˆ°äº† video.onseeked äº‹ä»¶ä¸­
                    }

                    video.onseeked = async function() {
                        try {
                            // æ£€æŸ¥è§†é¢‘æ˜¯å¦å‡†å¤‡å¥½
                            if (video.readyState < 2) {
                                console.log('è§†é¢‘æœªå‡†å¤‡å¥½ï¼Œè·³è¿‡å½“å‰å¸§');
                                currentFrame++;
                                setTimeout(processNextFrame, 10);
                                return;
                            }
                            
                            // åœ¨å¤„ç†å¸§ä¹‹å‰å…ˆæ›´æ–°è¿›åº¦
                            const frameProgress = (currentFrame / totalFrames);
                            const progress = 20 + (frameProgress * 65);
                            
                            // è®¡ç®—æ—¶é—´ä¿¡æ¯
                            const elapsed = performance.now() - processingStartTime;
                            const estimatedTotal = totalFrames > 0 ? (elapsed / (currentFrame + 1)) * totalFrames : 0;
                            const remaining = Math.max(0, estimatedTotal - elapsed);
                            
                            const stage = 'å¤„ç†è§†é¢‘å¸§';
                            const details = `${currentFrame + 1}/${totalFrames} (${(frameProgress * 100).toFixed(1)}%) - é¢„è®¡å‰©ä½™ ${Math.round(remaining / 1000)}s`;
                            
                            // ç«‹å³æ›´æ–°è¿›åº¦æ˜¾ç¤º
                            progressCallback(progress, stage, details);
                            
                            // æ£€æŸ¥ç”»å¸ƒå°ºå¯¸
                            if (canvas.width === 0 || canvas.height === 0) {
                                throw new Error(`ç”»å¸ƒå°ºå¯¸æ— æ•ˆ: ${canvas.width}x${canvas.height}`);
                            }
                            
                            // æ¸…ç©ºç”»å¸ƒ
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            
                            // ç»˜åˆ¶å½“å‰å¸§
                            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);
                            
                            // è·å–å›¾åƒæ•°æ®å¹¶æ£€æŸ¥æœ‰æ•ˆæ€§
                            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
                            
                            if (!imageData || imageData.width === 0 || imageData.height === 0) {
                                throw new Error(`å›¾åƒæ•°æ®æ— æ•ˆ: ${imageData ? imageData.width + 'x' + imageData.height : 'null'}`);
                            }
                            
                            // å¤„ç†èƒŒæ™¯ï¼ˆWorker ä¼˜å…ˆï¼‰
                            let processedData;
                            try {
                                processedData = await processFrameInWorker(imageData);
                            } catch (workerErr) {
                                console.warn('Workerå¤„ç†å¤±è´¥ï¼Œå›é€€ä¸»çº¿ç¨‹ç®—æ³•:', workerErr && workerErr.message ? workerErr.message : workerErr);
                                processedData = removeBackground(imageData);
                            }
                            ctx.putImageData(processedData, 0, 0);

                            // å»æ°´å°ï¼šåœ¨å·¦ä¸Šè§’ ROI å åŠ é€æ˜é®ç½©ï¼ˆdestination-outï¼‰ï¼Œæ”¯æŒç¾½åŒ–
                            if (currentSettings.wmEnabled) {
                                try {
                                    const fw = canvas.width;
                                    const fh = canvas.height;
                                    const rx = Math.max(0, Math.min(100, currentSettings.wmX || 0)) / 100 * fw;
                                    const ry = Math.max(0, Math.min(100, currentSettings.wmY || 0)) / 100 * fh;
                                    const rw = Math.max(1, Math.min(fw, (currentSettings.wmW || 0) / 100 * fw));
                                    const rh = Math.max(1, Math.min(fh, (currentSettings.wmH || 0) / 100 * fh));
                                    const featherPx = Math.max(0, Number(currentSettings.wmFeather || 0));

                                    ctx.save();
                                    ctx.globalCompositeOperation = 'destination-out';
                                    if (featherPx > 0) {
                                        // ç»˜åˆ¶å¸¦ç¾½åŒ–çš„çŸ©å½¢ï¼šå…ˆç»˜åˆ¶ä¸é€æ˜ï¼Œå†åº”ç”¨æ¨¡ç³Šå®ç°æŸ”è¾¹
                                        // ä½¿ç”¨ç¦»å±ç”»å¸ƒæå‡æ€§èƒ½å¹¶é¿å…å½±å“ä¸»ç”»å¸ƒçŠ¶æ€
                                        const off = document.createElement('canvas');
                                        off.width = fw; off.height = fh;
                                        const octx = off.getContext('2d');
                                        octx.fillStyle = '#000';
                                        // æ‰©å¤§å¡«å……ä»¥è¦†ç›–ç¾½åŒ–åŠå¾„
                                        octx.fillRect(rx, ry, rw, rh);
                                        // å°†ç¦»å±æ¨¡ç³Šåå åŠ 
                                        ctx.filter = `blur(${featherPx}px)`;
                                        ctx.drawImage(off, 0, 0);
                                        ctx.filter = 'none';
                                    } else {
                                        ctx.fillStyle = '#000';
                                        ctx.fillRect(rx, ry, rw, rh);
                                    }
                                    ctx.restore();
                                } catch (e) {
                                    console.warn('å»æ°´å°é®ç½©å¤±è´¥:', e);
                                }
                            }
                            
                            // ä¿å­˜å¸§
                            const frameData = canvas.toDataURL('image/webp', 0.8);
                            if (frameData && frameData.length > 100) { // ç¡®ä¿å¸§æ•°æ®æœ‰æ•ˆ
                                frames.push(frameData);
                            }
                            
                            console.log(`å¤„ç†å¸§ ${currentFrame + 1}/${Math.floor(video.duration * targetFPS)} (æ—¶é—´: ${(currentFrame / targetFPS).toFixed(2)}s)`);
                            
                            currentFrame++;
                            
                            // å¤„ç†ä¸‹ä¸€å¸§ï¼šå¯è§æ€§æ„ŸçŸ¥ï¼Œåå°ç›´æ¥ç­‰å¾…å‰å°ï¼Œæ— éœ€è½®è¯¢
                            if (pageHidden) {
                                try { await waitForVisible(); } catch (_) {}
                                setTimeout(processNextFrame, 20);
                            } else {
                                setTimeout(processNextFrame, 40);
                            }
                            
                        } catch (error) {
                            console.error('å¸§å¤„ç†é”™è¯¯:', error);
                            // å°è¯•ç»§ç»­å¤„ç†ä¸‹ä¸€å¸§ï¼Œä½†å¦‚æœé”™è¯¯å¤ªå¤šåˆ™åœæ­¢
                            currentFrame++;
                            if (currentFrame - frames.length > 10) {
                                reject(new Error(`å¸§å¤„ç†å¤±è´¥è¿‡å¤š: ${error.message}`));
                                return;
                            }
                            if (pageHidden) {
                                try { await waitForVisible(); } catch (_) {}
                                setTimeout(processNextFrame, 40);
                            } else {
                                setTimeout(processNextFrame, 60);
                            }
                        }
                    };

                    // å¼€å§‹å¤„ç†ç¬¬ä¸€å¸§
                    processNextFrame();
                }

                function removeBackground(imageData) {
                    const data = imageData.data;
                    const targetColor = hexToRgb(currentSettings.color);
                    const tolerance = currentSettings.tolerance / 100 * 255;
                    const feather = currentSettings.feather;

                    for (let i = 0; i < data.length; i += 4) {
                        const r = data[i];
                        const g = data[i + 1];
                        const b = data[i + 2];

                        // è®¡ç®—é¢œè‰²å·®å¼‚
                        const diff = Math.sqrt(
                            Math.pow(r - targetColor.r, 2) +
                            Math.pow(g - targetColor.g, 2) +
                            Math.pow(b - targetColor.b, 2)
                        );

                        // å¦‚æœé¢œè‰²æ¥è¿‘ç›®æ ‡é¢œè‰²ï¼Œè®¾ç½®ä¸ºé€æ˜
                        if (diff <= tolerance) {
                            let alpha = 0;
                            if (feather > 0) {
                                // è¾¹ç¼˜ç¾½åŒ–
                                const featherRange = feather * 10;
                                if (diff > tolerance - featherRange) {
                                    alpha = (diff - (tolerance - featherRange)) / featherRange;
                                }
                            }
                            data[i + 3] = Math.floor(alpha * 255);
                        }
                    }

                    return imageData;
                }

                async function generateOutput() {
                    try {
                        progressCallback(90, 'ç”Ÿæˆè§†é¢‘', 'å‡†å¤‡ç¼–ç è§†é¢‘æ•°æ®...');
                        console.log('å¼€å§‹ç”Ÿæˆè§†é¢‘...');
                        
                        if (frames.length === 0) {
                            throw new Error('æ²¡æœ‰å¤„ç†åˆ°æœ‰æ•ˆå¸§');
                        }

                        progressCallback(95, 'ç”Ÿæˆè§†é¢‘', 'æ­£åœ¨ç¼–ç WebMæ ¼å¼...');
                        
                        // ä½¿ç”¨æ”¹è¿›çš„è§†é¢‘ç”Ÿæˆæ–¹æ³•
                        const webmBlob = await createWebMFromFrames(frames, video.duration, targetFPS);
                        const url = URL.createObjectURL(webmBlob);
                        
                        progressCallback(99, 'å®Œæˆå¤„ç†', 'ç”Ÿæˆä¸‹è½½é“¾æ¥...');
                        console.log('è§†é¢‘ç”Ÿæˆå®Œæˆ');
                        
                        // æœ€ç»ˆå®Œæˆ
                        progressCallback(100, 'å¤„ç†å®Œæˆ', `æˆåŠŸç”Ÿæˆ ${frames.length} å¸§é€æ˜è§†é¢‘`);
                        
                        resolve({
                            blob: webmBlob,
                            url: url,
                            duration: video.duration,
                            frames: frames.length
                        });
                    } catch (error) {
                        console.error('è§†é¢‘ç”Ÿæˆå¤±è´¥:', error);
                        reject(error);
                    }
                }

                // åŠ è½½è§†é¢‘æ–‡ä»¶
                video.src = URL.createObjectURL(file);
                video.load();
            });
        }

        // ä½¿ç”¨ FFmpeg.wasm å¤„ç†ï¼ˆé¡µé¢éšè—ä¹Ÿèƒ½æŒç»­ï¼‰
        async function processVideoFileWithFFmpeg(file, progressCallback) {
            progressCallback(12, 'åŠ è½½æ–‡ä»¶', 'è¯»å–è§†é¢‘æ•°æ®åˆ°å†…å­˜');
            const arrayBuffer = await file.arrayBuffer();
            const fileName = file.name || 'input.mp4';
            progressCallback(18, 'å¯åŠ¨å¼•æ“', 'å‡†å¤‡æ‰§è¡ŒæŠ åƒä¸ç¼–ç ');

            const worker = await ensureFfmpegWorker();
            if (!worker || !ffmpegReady) {
                throw new Error('FFmpeg å¼•æ“åˆå§‹åŒ–å¤±è´¥');
            }

            const startTs = performance.now();
            const p = new Promise((resolve, reject) => {
                const onMsg = (ev) => {
                    const d = ev.data || {};
                    if (d.type === 'convert:ok') {
                        worker.removeEventListener('message', onMsg);
                        const blob = new Blob([d.payload.buffer], { type: 'video/webm' });
                        const url = URL.createObjectURL(blob);
                        const elapsed = performance.now() - startTs;
                        progressCallback(100, 'å¤„ç†å®Œæˆ', `è€—æ—¶ ${(elapsed/1000).toFixed(1)}s`);
                        resolve({ blob, url, duration: 0, frames: 0 });
                    } else if (d.type === 'error') {
                        worker.removeEventListener('message', onMsg);
                        reject(new Error(d.payload && d.payload.message ? d.payload.message : 'FFmpeg å¤„ç†å¤±è´¥'));
                    }
                };
                worker.addEventListener('message', onMsg);
            });

            // å‘é€ä»»åŠ¡
            worker.postMessage({ type: 'convert', payload: { fileBuffer: arrayBuffer, fileName, settings: currentSettings } }, [arrayBuffer]);

            // ç®€å•çš„è¿›åº¦è½®è¯¢ï¼ˆffmpeg.min.js çš„ log=false é»˜è®¤ä¸æ¨é€è¿›åº¦ï¼›å¯åç»­ç”¨ ffmpeg.setLogger è·å–ï¼‰
            let fake = 20;
            const tick = () => {
                if (fake < 95) {
                    fake += Math.random() * 3;
                    progressCallback(Math.min(95, fake), 'FFmpegå¤„ç†ä¸­', 'è¯·ä¿æŒæµè§ˆå™¨è¿è¡Œ');
                    setTimeout(tick, 600);
                }
            };
            setTimeout(tick, 600);

            return p;
        }

        // ä»å¸§åˆ›å»ºWebMï¼ˆæ”¹è¿›ç‰ˆæœ¬ï¼‰
        async function createWebMFromFrames(frames, duration, fps = 15) {
            console.log(`ç”Ÿæˆè§†é¢‘: ${frames.length} å¸§, ${duration}s, ${fps}FPS`);
            
            if (frames.length === 0) {
                throw new Error('æ²¡æœ‰å¸§æ•°æ®');
            }

            const canvas = document.createElement('canvas');
            const ctx = canvas.getContext('2d');
            
            // è®¾ç½®ç”»å¸ƒå¤§å°
            const firstImg = new Image();
            await new Promise((resolve, reject) => {
                firstImg.onload = resolve;
                firstImg.onerror = reject;
                firstImg.src = frames[0];
            });
            
            canvas.width = firstImg.width;
            canvas.height = firstImg.height;
            
            console.log(`ç”»å¸ƒå°ºå¯¸: ${canvas.width}x${canvas.height}`);

            // æ£€æµ‹æµè§ˆå™¨æ”¯æŒçš„ç¼–ç æ ¼å¼
            let mimeType = 'video/webm;codecs=vp8';
            if (MediaRecorder.isTypeSupported('video/webm;codecs=vp9')) {
                mimeType = 'video/webm;codecs=vp9';
            } else if (MediaRecorder.isTypeSupported('video/webm;codecs=vp8')) {
                mimeType = 'video/webm;codecs=vp8';
            } else if (MediaRecorder.isTypeSupported('video/webm')) {
                mimeType = 'video/webm';
            } else {
                throw new Error('æµè§ˆå™¨ä¸æ”¯æŒWebMæ ¼å¼å½•åˆ¶');
            }
            
            console.log('ä½¿ç”¨ç¼–ç æ ¼å¼:', mimeType);

            // åˆ›å»ºè§†é¢‘æµ
            const stream = canvas.captureStream(fps);
            const recorder = new MediaRecorder(stream, {
                mimeType: mimeType,
                videoBitsPerSecond: 2000000 // 2Mbps
            });

            const chunks = [];
            let isRecording = false;

            recorder.ondataavailable = function(e) {
                if (e.data && e.data.size > 0) {
                    chunks.push(e.data);
                    console.log('å½•åˆ¶æ•°æ®å—:', e.data.size, 'bytes');
                }
            };

            return new Promise((resolve, reject) => {
                let stoppedByLogic = false;

                recorder.onstop = function() {
                    console.log('å½•åˆ¶å®Œæˆï¼Œæ•°æ®å—æ•°é‡:', chunks.length);
                    
                    if (chunks.length === 0) {
                        reject(new Error('æ²¡æœ‰å½•åˆ¶åˆ°æ•°æ®'));
                        return;
                    }
                    
                    const blob = new Blob(chunks, { type: 'video/webm' });
                    console.log('ç”Ÿæˆè§†é¢‘å¤§å°:', blob.size, 'bytes');
                    
                    if (blob.size === 0) {
                        reject(new Error('ç”Ÿæˆçš„è§†é¢‘æ–‡ä»¶ä¸ºç©º'));
                        return;
                    }
                    
                    resolve(blob);
                };

                recorder.onerror = function(e) {
                    console.error('å½•åˆ¶é”™è¯¯:', e);
                    reject(new Error('è§†é¢‘å½•åˆ¶å¤±è´¥: ' + (e.error || e.message || 'æœªçŸ¥é”™è¯¯')));
                };

                // å¼€å§‹å½•åˆ¶
                try {
                    recorder.start(100); // æ¯100msæ”¶é›†ä¸€æ¬¡æ•°æ®
                    isRecording = true;
                    console.log('å¼€å§‹å½•åˆ¶...');
                } catch (error) {
                    clearTimeout(timeout);
                    reject(new Error('æ— æ³•å¼€å§‹å½•åˆ¶: ' + error.message));
                    return;
                }

                // æ’­æ”¾å¸§åºåˆ—
                let frameIndex = 0;
                const frameDuration = 1000 / fps; // æ¯å¸§æŒç»­æ—¶é—´(ms)
                
                async function playNextFrame() {
                    if (frameIndex >= frames.length) {
                        console.log('å¸§æ’­æ”¾å®Œæˆï¼Œåœæ­¢å½•åˆ¶...');
                        setTimeout(() => {
                            if (isRecording) {
                                recorder.stop();
                                isRecording = false;
                            }
                        }, 500); // ç­‰å¾…æœ€åä¸€å¸§
                        return;
                    }

                    // å¦‚æœçª—å£åœ¨åå°ï¼Œåˆ™æš‚åœæ¨è¿›ç›´åˆ°å›åˆ°å‰å°ï¼Œé¿å… MediaRecorder/ç»˜åˆ¶åœæ‘†
                    if (pageHidden) {
                        try { await waitForVisible(); } catch (_) {}
                    }

                    const img = new Image();
                    img.onload = function() {
                        try {
                            ctx.clearRect(0, 0, canvas.width, canvas.height);
                            ctx.drawImage(img, 0, 0);
                            
                            frameIndex++;
                            if (pageHidden) {
                                // åå°ä¸æ¨è¿›ï¼Œç­‰å¾…å‰å°
                                (async function(){ try { await waitForVisible(); } catch (_) {} setTimeout(playNextFrame, frameDuration); })();
                            } else {
                                setTimeout(playNextFrame, frameDuration);
                            }
                        } catch (error) {
                            console.error('ç»˜åˆ¶å¸§é”™è¯¯:', error);
                            frameIndex++;
                            if (pageHidden) {
                                (async function(){ try { await waitForVisible(); } catch (_) {} setTimeout(playNextFrame, frameDuration); })();
                            } else {
                                setTimeout(playNextFrame, frameDuration);
                            }
                        }
                    };
                    
                    img.onerror = function() {
                        console.error('åŠ è½½å¸§å¤±è´¥:', frameIndex);
                        frameIndex++;
                        if (pageHidden) {
                            (async function(){ try { await waitForVisible(); } catch (_) {} setTimeout(playNextFrame, frameDuration); })();
                        } else {
                            setTimeout(playNextFrame, frameDuration);
                        }
                    };
                    
                    img.src = frames[frameIndex];
                }

                // å¼€å§‹æ’­æ”¾å¸§
                setTimeout(playNextFrame, 100);
            });
        }

        // é¢œè‰²è½¬æ¢å·¥å…·
        function hexToRgb(hex) {
            const result = /^#?([a-f\d]{2})([a-f\d]{2})([a-f\d]{2})$/i.exec(hex);
            return result ? {
                r: parseInt(result[1], 16),
                g: parseInt(result[2], 16),
                b: parseInt(result[3], 16)
            } : { r: 0, g: 0, b: 0 };
        }

        // UI æ›´æ–°å‡½æ•°
        function updateFileStatus(index, status, details) {
            const statusEl = document.getElementById(`status-${index}`);
            if (statusEl) {
                statusEl.className = `status ${status}`;
                const statusText = getStatusText(status);
                statusEl.textContent = details ? `${statusText} - ${details}` : statusText;
            }
            // ä¸å†å¼ºåˆ¶é‡ç»˜æ•´ä¸ªæ–‡ä»¶åˆ—è¡¨ï¼Œé¿å…çŠ¶æ€å›é€€/é—ªçƒ
        }

        function showProgress(index) {
            const progressEl = document.getElementById(`progress-${index}`);
            if (progressEl) {
                progressEl.classList.remove('hidden');
            }
        }

        function updateProgress(index, progress, stage, details) {
            const progressEl = document.getElementById(`progress-${index}`);
            if (progressEl) {
                const fill = progressEl.querySelector('.progress-fill');
                const percentageEl = progressEl.querySelector('.progress-percentage');
                const stageEl = progressEl.querySelector('.progress-stage');
                const detailsEl = progressEl.querySelector('.progress-details');
                
                // æ›´æ–°è¿›åº¦æ¡
                if (fill) fill.style.width = `${progress}%`;
                
                // æ›´æ–°ç™¾åˆ†æ¯”
                if (percentageEl) percentageEl.textContent = `${Math.round(progress)}%`;
                
                // æ›´æ–°é˜¶æ®µä¿¡æ¯
                if (stageEl) stageEl.textContent = stage || '';
                
                // æ›´æ–°è¯¦ç»†ä¿¡æ¯
                if (detailsEl) detailsEl.textContent = details || '';
                
                // å¼ºåˆ¶é‡ç»˜ç¡®ä¿æ›´æ–°æ˜¾ç¤º
                progressEl.offsetHeight;
            }
            
            // åŒæ—¶æ›´æ–°çŠ¶æ€æ 
            if (stage) {
                updateFileStatus(index, 'processing', stage);
            }
            
            // è¾“å‡ºè°ƒè¯•ä¿¡æ¯
            console.log(`Progress updated: ${Math.round(progress)}% - ${stage} - ${details}`);

            // åŒæ­¥å†…å­˜çŠ¶æ€ï¼Œé˜²æ­¢é‡ç»˜å›é€€
            const file = selectedFiles[index];
            if (file) {
                const prev = processedFiles.get(file.name) || {};
                processedFiles.set(file.name, { ...prev, status: 'processing', progress: Math.round(progress) });
            }
        }

        function hideProgress(index) {
            const progressEl = document.getElementById(`progress-${index}`);
            if (progressEl) {
                progressEl.classList.add('hidden');
            }
        }

        function addPreview(index, url) {
            const fileItem = document.getElementById(`file-${index}`);
            if (fileItem && !fileItem.querySelector('.preview-container')) {
                const previewHtml = `
                    <div class="preview-container">
                        <video class="preview-video" controls muted>
                            <source src="${url}" type="video/webm">
                        </video>
                    </div>
                `;
                fileItem.insertAdjacentHTML('beforeend', previewHtml);
            }
        }

        // åˆ·æ–°æ–‡ä»¶åŠ¨ä½œæŒ‰é’®ï¼ˆç”¨äºåœ¨å¤„ç†æˆåŠŸåæ˜¾ç¤ºå•ä¸ªä¸‹è½½ï¼‰
        function refreshFileActions(index) {
            const file = selectedFiles[index];
            const fileItem = document.getElementById(`file-${index}`);
            const actions = fileItem ? fileItem.querySelector('.file-actions') : null;
            if (!file || !actions) return;
            const pf = processedFiles.get(file.name);
            if (pf && pf.status === 'success') {
                actions.innerHTML = `
                    <button class="btn btn-small" onclick="downloadFile(${index})">ğŸ’¾ ä¸‹è½½</button>
                    <button class="btn btn-small" onclick="downloadFileToFolder(${index})" style="background: linear-gradient(135deg, #28a745 0%, #20c997 100%); font-size: 0.8rem;">ğŸ“ ä¸‹è½½åˆ°video/</button>
                    <button class="btn btn-small" onclick="previewFile(${index})">ğŸ‘€ é¢„è§ˆ</button>
                    <button class="btn btn-small danger" onclick="removeFile(${index})">âŒ ç§»é™¤</button>
                `;
            } else if (pf && pf.status === 'processing') {
                actions.innerHTML = `
                    <button class="btn btn-small" disabled>ğŸ”„ è½¬æ¢ä¸­...</button>
                    <button class="btn btn-small danger" onclick="removeFile(${index})">âŒ ç§»é™¤</button>
                `;
            } else {
                actions.innerHTML = `
                    <button class="btn btn-small" onclick="convertSingleFile(${index})">ğŸ”„ è½¬æ¢</button>
                    <button class="btn btn-small danger" onclick="removeFile(${index})">âŒ ç§»é™¤</button>
                `;
            }
        }

        function addErrorDetails(index, errorMessage) {
            const fileItem = document.getElementById(`file-${index}`);
            if (fileItem && !fileItem.querySelector('.error-details')) {
                const errorHtml = `
                    <div class="error-details" style="
                        margin-top: 12px;
                        padding: 12px;
                        background: #fff5f5;
                        border: 1px solid #fed7d7;
                        border-radius: 6px;
                        font-size: 0.9rem;
                        color: #c53030;
                    ">
                        <div style="font-weight: 600; margin-bottom: 8px;">âŒ é”™è¯¯è¯¦æƒ…:</div>
                        <div>${errorMessage}</div>
                        <div style="margin-top: 8px;">
                            <button class="btn btn-small" onclick="diagnoseError(${index})" style="background: #e53e3e;">
                                ğŸ” è¯Šæ–­é—®é¢˜
                            </button>
                            <button class="btn btn-small" onclick="retryProcessing(${index})" style="background: #3182ce;">
                                ğŸ”„ é‡è¯•
                            </button>
                        </div>
                    </div>
                `;
                fileItem.insertAdjacentHTML('beforeend', errorHtml);
            }
        }

        // å…¨å±€å˜é‡ï¼šç”¨äºè·Ÿè¸ªä¸‹è½½åºå·
        let downloadCounter = 1;
        const MAX_DOWNLOAD_NUMBER = 200;

        // ç›®å½•å¥æŸ„ï¼šç”¨æˆ·é€‰æ‹©çš„è¾“å‡ºç›®å½•ï¼ˆéœ€æ”¯æŒ File System Access APIï¼‰
        let outputDirHandle = null;

        // ç¡®ä¿å·²é€‰æ‹©è¾“å‡ºç›®å½•ï¼ˆé¦–æ¬¡è°ƒç”¨ä¼šè¯·æ±‚æƒé™ï¼‰
        async function ensureOutputDirectory(userInitiated = false) {
            if (outputDirHandle) return outputDirHandle;
            if (!window.showDirectoryPicker) {
                showToast('æµè§ˆå™¨ä¸æ”¯æŒé€‰æ‹©æ–‡ä»¶å¤¹ï¼Œå°†ä½¿ç”¨æ™®é€šä¸‹è½½æ–¹å¼', 'warning');
                return null;
            }
            if (!userInitiated) {
                // éç”¨æˆ·æ‰‹åŠ¿è§¦å‘ï¼Œä¸å¼¹ç³»ç»Ÿé€‰æ‹©å™¨ï¼Œé¿å…é™çº§ä¸ºé»˜è®¤ä¸‹è½½
                showToast('è¯·å…ˆç‚¹å‡»â€œè®¾ç½®è¾“å‡ºç›®å½•(video)â€æŒ‰é’®', 'warning');
                highlightPickOutputButton();
                return null;
            }
            try {
                const handle = await window.showDirectoryPicker({ id: 'alphavid-output', mode: 'readwrite' });
                const ok = await verifyOutputPermission(handle);
                if (!ok) {
                    showToast('æœªæˆäºˆå†™å…¥æƒé™ï¼Œæ— æ³•ä¿å­˜åˆ°ç›®å½•', 'error');
                    return null;
                }
                outputDirHandle = handle;
                showToast('å·²é€‰æ‹©è¾“å‡ºæ–‡ä»¶å¤¹', 'success');
                updatePickOutputButton(true);
                return handle;
            } catch (e) {
                console.warn('é€‰æ‹©è¾“å‡ºæ–‡ä»¶å¤¹è¢«å–æ¶ˆæˆ–å¤±è´¥:', e);
                showToast('æœªé€‰æ‹©è¾“å‡ºæ–‡ä»¶å¤¹', 'warning');
                return null;
            }
        }

        async function verifyOutputPermission(handle) {
            try {
                const q = await handle.queryPermission({ mode: 'readwrite' });
                if (q === 'granted') return true;
                const r = await handle.requestPermission({ mode: 'readwrite' });
                return r === 'granted';
            } catch (_) { return false; }
        }

        function updatePickOutputButton(set) {
            const btn = document.getElementById('pickOutputBtn');
            if (!btn) return;
            if (set) {
                btn.textContent = 'ğŸ“ å·²è®¾ç½®è¾“å‡ºç›®å½•';
            } else {
                btn.textContent = 'ğŸ“ è®¾ç½®è¾“å‡ºç›®å½•(video)';
            }
        }

        function highlightPickOutputButton() {
            const btn = document.getElementById('pickOutputBtn');
            if (!btn) return;
            btn.style.boxShadow = '0 0 0 4px rgba(255,127,80,0.35)';
            setTimeout(() => { btn.style.boxShadow = ''; }, 1200);
        }

        // å°†Blobå†™å…¥æŒ‡å®šç›®å½•
        async function saveBlobToDirectory(dirHandle, fileName, blob) {
            try {
                const fileHandle = await dirHandle.getFileHandle(fileName, { create: true });
                const writable = await fileHandle.createWritable();
                await writable.write(blob);
                await writable.close();
                return true;
            } catch (e) {
                console.error('å†™å…¥æ–‡ä»¶å¤±è´¥:', e);
                return false;
            }
        }

        // æ‰«æç›®å½•è·å–å·²å­˜åœ¨çš„æœ€å¤§æ•°å­—ç´¢å¼•ï¼ˆå½¢å¦‚ 1.webm, 2.webm ...ï¼‰
        async function getMaxExistingIndex(dirHandle) {
            let maxNum = 0;
            try {
                for await (const [name, handle] of dirHandle.entries()) {
                    if (handle.kind === 'file') {
                        const match = /^([0-9]{1,4})\.webm$/i.exec(name);
                        if (match) {
                            const num = parseInt(match[1], 10);
                            if (!Number.isNaN(num)) {
                                if (num > maxNum) maxNum = num;
                            }
                        }
                    }
                }
            } catch (e) {
                console.warn('è¯»å–ç›®å½•å†…å®¹å¤±è´¥:', e);
            }
            return maxNum;
        }

        // è·å–ç›®å½•ä¸­ä¸‹ä¸€ä¸ªå¯ç”¨çš„æ•°å­—æ–‡ä»¶åï¼ˆè¿”å›ä¾‹å¦‚ "4.webm"ï¼‰ï¼Œè¶…å‡ºä¸Šé™åˆ™è¿”å›null
        async function getNextAvailableName(dirHandle) {
            const maxNum = await getMaxExistingIndex(dirHandle);
            let next = Math.max(maxNum + 1, downloadCounter);
            if (next > MAX_DOWNLOAD_NUMBER) return null;
            // æå‰æ¨è¿›è®¡æ•°å™¨ï¼Œç¡®ä¿è¿ç»­
            downloadCounter = next + 1;
            return `${next}.webm`;
        }

        // ä¿å­˜ä¸€ä¸ªå¤„ç†å®Œæˆçš„ Blob åˆ°è¾“å‡ºç›®å½•ï¼ˆç«‹å³ä¿å­˜ï¼‰
        async function saveProcessedFileDirect(blob) {
            const dir = await ensureOutputDirectory(false);
            if (!dir) {
                showToast('æœªè®¾ç½®è¾“å‡ºç›®å½•ï¼Œæ— æ³•ä¿å­˜', 'warning');
                return false;
            }
            const candidate = await getNextAvailableName(dir);
            if (!candidate) {
                showToast(`è¶…è¿‡æœ€å¤§æ•°é‡é™åˆ¶(${MAX_DOWNLOAD_NUMBER})ï¼Œè¯·æ›´æ¢ç›®å½•æˆ–é‡ç½®åºå·`, 'warning');
                return false;
            }
            const ok = await saveBlobToDirectory(dir, candidate, blob);
            if (ok) {
                showToast(`å·²ä¿å­˜: ${candidate}`, 'success');
            }
            return ok;
        }

        // é‡ç½®ä¸‹è½½è®¡æ•°å™¨
        function resetDownloadCounter() {
            downloadCounter = 1;
        }

        // è·å–ä¸‹ä¸€ä¸ªå¯ç”¨çš„ä¸‹è½½åºå·
        function getNextDownloadNumber() {
            if (downloadCounter > MAX_DOWNLOAD_NUMBER) {
                downloadCounter = 1; // é‡æ–°å¼€å§‹
            }
            return downloadCounter++;
        }

        // ä¸‹è½½å•ä¸ªæ–‡ä»¶åˆ°æŒ‡å®šæ–‡ä»¶å¤¹
        async function downloadFileToFolder(index) {
            const file = selectedFiles[index];
            if (!file) return;

            const processedFile = processedFiles.get(file.name);
            if (!processedFile || processedFile.status !== 'success') {
                showToast('æ–‡ä»¶å°šæœªå¤„ç†å®Œæˆ', 'warning');
                return;
            }

            try {
                // ä¼˜å…ˆå°è¯•å†™å…¥åˆ°ç”¨æˆ·é€‰æ‹©çš„ç›®å½•
                const dir = await ensureOutputDirectory(false);
                if (dir) {
                    // è¯»å–ç›®å½•ä¸­ç°æœ‰æœ€å¤§ç¼–å·ï¼Œå¹¶ä»å…¶åå¼€å§‹å‘½å
                    const candidate = await getNextAvailableName(dir);
                    if (!candidate) {
                        showToast(`è¶…è¿‡æœ€å¤§æ•°é‡é™åˆ¶(${MAX_DOWNLOAD_NUMBER})ï¼Œè¯·æ›´æ¢ç›®å½•æˆ–é‡ç½®åºå·`, 'warning');
                        return;
                    }
                    const ok = await saveBlobToDirectory(dir, candidate, processedFile.blob);
                    if (ok) {
                        showToast(`å·²ä¿å­˜: ${candidate}`, 'success');
                        return;
                    } else {
                        showToast('ç›®å½•å†™å…¥å¤±è´¥ï¼Œæ”¹ç”¨æ™®é€šä¸‹è½½æ–¹å¼', 'warning');
                    }
                }

                // å›é€€ï¼šä½¿ç”¨æµè§ˆå™¨ä¸‹è½½ï¼ˆæ— æ³•å¼ºåˆ¶æŒ‡å®šæ–‡ä»¶å¤¹ï¼‰
                const number = getNextDownloadNumber();
                const fallbackName = `${number}.webm`;
                const a = document.createElement('a');
                a.href = processedFile.url;
                a.download = fallbackName;
                document.body.appendChild(a);
                a.click();
                document.body.removeChild(a);
                showToast(`å¼€å§‹ä¸‹è½½: ${fallbackName}`, 'success');
            } catch (error) {
                console.error('ä¸‹è½½å¤±è´¥:', error);
                showToast('ä¸‹è½½å¤±è´¥ï¼Œè¯·é‡è¯•', 'error');
            }
        }

        // æ‰¹é‡ä¸‹è½½æ‰€æœ‰æ–‡ä»¶åˆ°æŒ‡å®šæ–‡ä»¶å¤¹
        async function downloadAllToFolder() {
            const successFiles = Array.from(processedFiles.entries())
                .filter(([name, file]) => file.status === 'success');

            if (successFiles.length === 0) {
                showToast('æ²¡æœ‰å¯ä¸‹è½½çš„æ–‡ä»¶', 'warning');
                return;
            }

            if (successFiles.length > MAX_DOWNLOAD_NUMBER) {
                showToast(`æ–‡ä»¶æ•°é‡è¶…è¿‡é™åˆ¶ (${MAX_DOWNLOAD_NUMBER})ï¼Œè¯·åˆ†æ‰¹ä¸‹è½½`, 'warning');
                return;
            }

            // é‡ç½®è®¡æ•°å™¨ç¡®ä¿ä»1å¼€å§‹
            resetDownloadCounter();

            try {
                const dir = await ensureOutputDirectory(false);

                if (dir) {
                    // ä»ç›®å½•ä¸­æœ€å¤§ç¼–å·çš„ä¸‹ä¸€ä¸ªå¼€å§‹æ‰¹é‡å‘½å
                    const startName = await getNextAvailableName(dir);
                    if (!startName) {
                        showToast(`è¶…è¿‡æœ€å¤§æ•°é‡é™åˆ¶(${MAX_DOWNLOAD_NUMBER})ï¼Œè¯·æ›´æ¢ç›®å½•æˆ–é‡ç½®åºå·`, 'warning');
                        return;
                    }
                    // å·²åœ¨ getNextAvailableName ä¸­æ¨è¿›äº† downloadCounter
                    // é€ä¸ªå†™å…¥åˆ°ç›®å½•
                    for (let i = 0; i < successFiles.length; i++) {
                        const [, fileObj] = successFiles[i];
                        const nextName = await getNextAvailableName(dir);
                        if (!nextName) {
                            showToast(`å¯ç”¨å‘½åå·²åˆ°è¾¾ä¸Šé™ï¼Œå·²ä¿å­˜å‰ ${i} ä¸ª`, 'warning');
                            return;
                        }
                        const ok = await saveBlobToDirectory(dir, nextName, fileObj.blob);
                        console.log(`ä¿å­˜ ${i + 1}/${successFiles.length}: ${nextName} -> ${ok ? 'OK' : 'FAIL'}`);
                        await new Promise(r => setTimeout(r, 30));
                    }
                    showToast(`å·²ä¿å­˜ ${successFiles.length} ä¸ªæ–‡ä»¶`, 'success');
                    return;
                }

                // å›é€€ï¼šä½¿ç”¨æµè§ˆå™¨ä¸‹è½½ï¼ˆæ— æ³•å¼ºåˆ¶æŒ‡å®šæ–‡ä»¶å¤¹ï¼‰
                successFiles.forEach(([name, file], index) => {
                    setTimeout(() => {
                        const number = getNextDownloadNumber();
                        const newFileName = `${number}.webm`;
                        const a = document.createElement('a');
                        a.href = file.url;
                        a.download = newFileName;
                        document.body.appendChild(a);
                        a.click();
                        document.body.removeChild(a);
                    }, index * 500);
                });
                showToast(`å¼€å§‹ä¸‹è½½ ${successFiles.length} ä¸ªæ–‡ä»¶`, 'success');

            } catch (error) {
                console.error('æ‰¹é‡ä¸‹è½½å¤±è´¥:', error);
                showToast('æ‰¹é‡ä¸‹è½½å¤±è´¥ï¼Œè¯·é‡è¯•', 'error');
            }
        }

        // æ–‡ä»¶æ“ä½œå‡½æ•°
        function removeFile(index) {
            const file = selectedFiles[index];
            if (file) {
                // æ¸…ç†URLå¯¹è±¡
                const processedFile = processedFiles.get(file.name);
                if (processedFile && processedFile.url) {
                    URL.revokeObjectURL(processedFile.url);
                }
                
                selectedFiles.splice(index, 1);
                processedFiles.delete(file.name);
                displayFileList();
                showToast('æ–‡ä»¶å·²ç§»é™¤', 'success');
            }
        }

        function clearAllFiles() {
            // æ¸…ç†æ‰€æœ‰URLå¯¹è±¡
            processedFiles.forEach(file => {
                if (file.url) {
                    URL.revokeObjectURL(file.url);
                }
            });
            
            selectedFiles = [];
            processedFiles.clear();
            displayFileList();
            
            // æ¸…ç†æ–‡ä»¶è¾“å…¥
            document.getElementById('fileInput').value = '';
            showToast('æ‰€æœ‰æ–‡ä»¶å·²æ¸…é™¤', 'success');
        }

        function downloadFile(index) {
            const file = selectedFiles[index];
            if (!file) return;

            const processedFile = processedFiles.get(file.name);
            if (!processedFile || processedFile.status !== 'success') {
                showToast('æ–‡ä»¶å°šæœªå¤„ç†å®Œæˆ', 'warning');
                return;
            }

            // åˆ›å»ºä¸‹è½½é“¾æ¥
            const a = document.createElement('a');
            a.href = processedFile.url;
            a.download = file.name.replace(/\.[^/.]+$/, '_transparent.webm');
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);

            showToast('å¼€å§‹ä¸‹è½½', 'success');
        }

        function downloadAll() {
            const successFiles = Array.from(processedFiles.entries())
                .filter(([name, file]) => file.status === 'success');

            if (successFiles.length === 0) {
                showToast('æ²¡æœ‰å¯ä¸‹è½½çš„æ–‡ä»¶', 'warning');
                return;
            }

            // é€ä¸ªä¸‹è½½æ–‡ä»¶
            successFiles.forEach(([name, file], index) => {
                setTimeout(() => {
                    const a = document.createElement('a');
                    a.href = file.url;
                    a.download = name.replace(/\.[^/.]+$/, '_transparent.webm');
                    document.body.appendChild(a);
                    a.click();
                    document.body.removeChild(a);
                }, index * 500); // é—´éš”500msä¸‹è½½
            });

            showToast(`å¼€å§‹ä¸‹è½½ ${successFiles.length} ä¸ªæ–‡ä»¶`, 'success');
        }

        function previewFile(index) {
            const file = selectedFiles[index];
            if (!file) return;

            const processedFile = processedFiles.get(file.name);
            if (!processedFile || processedFile.status !== 'success') {
                showToast('æ–‡ä»¶å°šæœªå¤„ç†å®Œæˆ', 'warning');
                return;
            }

            // æ»šåŠ¨åˆ°é¢„è§ˆåŒºåŸŸ
            const fileItem = document.getElementById(`file-${index}`);
            const preview = fileItem.querySelector('.preview-video');
            if (preview) {
                preview.scrollIntoView({ behavior: 'smooth', block: 'center' });
                preview.play();
            }
        }

        // é€šçŸ¥ç³»ç»Ÿ
        function showToast(message, type = 'success') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = `toast ${type}`;
            toast.classList.add('show');

            setTimeout(() => {
                toast.classList.remove('show');
            }, 3000);
        }

        // æ˜¾ç¤ºåŠ è½½è¦†ç›–å±‚
        function showLoading() {
            document.getElementById('loadingOverlay').classList.add('show');
        }

        function hideLoading() {
            document.getElementById('loadingOverlay').classList.remove('show');
        }

        // é¡µé¢å¸è½½æ—¶æ¸…ç†èµ„æº
        window.addEventListener('beforeunload', function() {
            processedFiles.forEach(file => {
                if (file.url) {
                    URL.revokeObjectURL(file.url);
                }
            });
        });

        // è¯Šæ–­é”™è¯¯åŠŸèƒ½
        function diagnoseError(index) {
            const file = selectedFiles[index];
            if (!file) return;

            const processedFile = processedFiles.get(file.name);
            if (!processedFile || processedFile.status !== 'error') return;

            let diagnosis = [];
            
            // æ£€æŸ¥æ–‡ä»¶åŸºæœ¬ä¿¡æ¯
            diagnosis.push(`ğŸ“ æ–‡ä»¶ä¿¡æ¯: ${file.name} (${formatFileSize(file.size)})`);
            diagnosis.push(`ğŸ“„ æ–‡ä»¶ç±»å‹: ${file.type}`);
            
            // æ£€æŸ¥æµè§ˆå™¨æ”¯æŒ
            const supportedFormats = [];
            ['video/webm;codecs=vp9', 'video/webm;codecs=vp8', 'video/webm'].forEach(format => {
                if (MediaRecorder.isTypeSupported(format)) {
                    supportedFormats.push(format);
                }
            });
            diagnosis.push(`ğŸŒ æ”¯æŒæ ¼å¼: ${supportedFormats.join(', ')}`);
            
            // æ£€æŸ¥é”™è¯¯ç±»å‹
            const error = processedFile.fullError || {};
            diagnosis.push(`âŒ é”™è¯¯ç±»å‹: ${error.name || 'æœªçŸ¥'}`);
            diagnosis.push(`ğŸ“ é”™è¯¯ä¿¡æ¯: ${processedFile.error}`);
            
            // æä¾›è§£å†³å»ºè®®
            let suggestions = [];
            
            if (processedFile.error.includes('ä¸æ”¯æŒ')) {
                suggestions.push('â€¢ å°è¯•ä½¿ç”¨ Chrome æµè§ˆå™¨ï¼ˆå…¼å®¹æ€§æœ€å¥½ï¼‰');
                suggestions.push('â€¢ æ£€æŸ¥æµè§ˆå™¨ç‰ˆæœ¬æ˜¯å¦è¿‡ä½');
            }
            
            if (processedFile.error.includes('åŠ è½½å¤±è´¥')) {
                suggestions.push('â€¢ æ£€æŸ¥è§†é¢‘æ–‡ä»¶æ˜¯å¦æŸå');
                suggestions.push('â€¢ å°è¯•è½¬æ¢ä¸ºæ ‡å‡† MP4 æ ¼å¼');
            }
            
            if (processedFile.error.includes('å½•åˆ¶å¤±è´¥') || processedFile.error.includes('æ²¡æœ‰å½•åˆ¶åˆ°æ•°æ®')) {
                suggestions.push('â€¢ é™ä½è§†é¢‘è´¨é‡è®¾ç½®');
                suggestions.push('â€¢ å°è¯•å¤„ç†æ›´çŸ­çš„è§†é¢‘');
                suggestions.push('â€¢ å…³é—­å…¶ä»–å ç”¨å†…å­˜çš„ç¨‹åº');
            }
            
            if (file.size > 50 * 1024 * 1024) {
                suggestions.push('â€¢ æ–‡ä»¶è¿‡å¤§ï¼Œå»ºè®®å‹ç¼©åå†å¤„ç†');
            }
            
            if (suggestions.length === 0) {
                suggestions.push('â€¢ å°è¯•é‡æ–°å¯åŠ¨æµè§ˆå™¨');
                suggestions.push('â€¢ å°è¯•ä½¿ç”¨æ›´å°çš„æµ‹è¯•è§†é¢‘');
                suggestions.push('â€¢ æ£€æŸ¥ç³»ç»Ÿå†…å­˜æ˜¯å¦å……è¶³');
            }
            
            diagnosis.push(`\nğŸ’¡ è§£å†³å»ºè®®:`);
            diagnosis = diagnosis.concat(suggestions);
            
            // æ˜¾ç¤ºè¯Šæ–­ç»“æœ
            const diagnosisText = diagnosis.join('\n');
            lastDiagnosticInfo = diagnosisText;
            
            // åˆ›å»ºè¯Šæ–­çª—å£
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 3000;
            `;
            
            modal.innerHTML = `
                <div style="
                    background: white;
                    padding: 24px;
                    border-radius: 12px;
                    max-width: 600px;
                    max-height: 80vh;
                    overflow-y: auto;
                    margin: 20px;
                ">
                    <h3 style="margin-bottom: 16px; color: #333;">ğŸ” é”™è¯¯è¯Šæ–­æŠ¥å‘Š</h3>
                    <pre style="
                        white-space: pre-wrap;
                        background: #f8f9fa;
                        padding: 16px;
                        border-radius: 6px;
                        font-size: 14px;
                        line-height: 1.5;
                        color: #333;
                        margin-bottom: 16px;
                    ">${diagnosisText}</pre>
                    <div style="text-align: right;">
                        <button class="btn" onclick="this.closest('[style*=fixed]').remove()">
                            å…³é—­
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // ç‚¹å‡»èƒŒæ™¯å…³é—­
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }

        // é‡è¯•å¤„ç†åŠŸèƒ½
        function retryProcessing(index) {
            const file = selectedFiles[index];
            if (!file) return;
            
            // æ¸…é™¤ä¹‹å‰çš„é”™è¯¯çŠ¶æ€
            processedFiles.delete(file.name);
            
            // ç§»é™¤é”™è¯¯è¯¦æƒ…
            const fileItem = document.getElementById(`file-${index}`);
            const errorDetails = fileItem.querySelector('.error-details');
            if (errorDetails) {
                errorDetails.remove();
            }
            
            // é‡æ–°å¼€å§‹å¤„ç†
            convertSingleFile(index);
        }

        // ç³»ç»Ÿè¯Šæ–­æµ‹è¯•
        function runDiagnosticTest() {
            const results = [];
            
            // æµ‹è¯•æµè§ˆå™¨åŸºæœ¬åŠŸèƒ½
            results.push('ğŸŒ æµè§ˆå™¨ç¯å¢ƒæµ‹è¯•:');
            results.push(`  â€¢ UserAgent: ${navigator.userAgent}`);
            results.push(`  â€¢ Canvasæ”¯æŒ: ${!!document.createElement('canvas').getContext('2d') ? 'âœ…' : 'âŒ'}`);
            results.push(`  â€¢ MediaRecorderæ”¯æŒ: ${!!window.MediaRecorder ? 'âœ…' : 'âŒ'}`);
            results.push(`  â€¢ URL.createObjectURLæ”¯æŒ: ${!!window.URL?.createObjectURL ? 'âœ…' : 'âŒ'}`);
            
            // æµ‹è¯•è§†é¢‘æ ¼å¼æ”¯æŒ
            results.push('\nğŸ¥ è§†é¢‘æ ¼å¼æ”¯æŒæµ‹è¯•:');
            const testFormats = [
                'video/webm;codecs=vp9',
                'video/webm;codecs=vp8', 
                'video/webm',
                'video/mp4;codecs=h264',
                'video/mp4'
            ];
            
            testFormats.forEach(format => {
                const supported = window.MediaRecorder && MediaRecorder.isTypeSupported(format);
                results.push(`  â€¢ ${format}: ${supported ? 'âœ…' : 'âŒ'}`);
            });
            
            // æµ‹è¯•å†…å­˜å’Œæ€§èƒ½
            results.push('\nğŸ’¾ ç³»ç»Ÿèµ„æºæµ‹è¯•:');
            if ('memory' in performance) {
                const memory = performance.memory;
                results.push(`  â€¢ å·²ç”¨å†…å­˜: ${Math.round(memory.usedJSHeapSize / 1024 / 1024)}MB`);
                results.push(`  â€¢ æ€»å†…å­˜: ${Math.round(memory.totalJSHeapSize / 1024 / 1024)}MB`);
                results.push(`  â€¢ å†…å­˜é™åˆ¶: ${Math.round(memory.jsHeapSizeLimit / 1024 / 1024)}MB`);
            } else {
                results.push('  â€¢ å†…å­˜ä¿¡æ¯: ä¸å¯ç”¨');
            }
            
            // æµ‹è¯•Canvaså½•åˆ¶
            results.push('\nğŸ¬ Canvaså½•åˆ¶æµ‹è¯•:');
            try {
                const canvas = document.createElement('canvas');
                canvas.width = 320;
                canvas.height = 240;
                const stream = canvas.captureStream(15);
                results.push(`  â€¢ Canvas.captureStream: âœ…`);
                
                if (stream.getVideoTracks().length > 0) {
                    results.push(`  â€¢ è§†é¢‘è½¨é“: âœ…`);
                } else {
                    results.push(`  â€¢ è§†é¢‘è½¨é“: âŒ`);
                }
            } catch (error) {
                results.push(`  â€¢ Canvas.captureStream: âŒ (${error.message})`);
            }
            
            // å»ºè®®å’Œè§£å†³æ–¹æ¡ˆ
            results.push('\nğŸ’¡ å»ºè®®:');
            
            if (!window.MediaRecorder) {
                results.push('  â€¢ è¯·ä½¿ç”¨æ”¯æŒMediaRecorderçš„ç°ä»£æµè§ˆå™¨');
                results.push('  â€¢ æ¨è: Chrome 85+, Firefox 80+, Safari 14+');
            } else {
                const hasWebM = MediaRecorder.isTypeSupported('video/webm');
                if (!hasWebM) {
                    results.push('  â€¢ æµè§ˆå™¨ä¸æ”¯æŒWebMæ ¼å¼ï¼ŒåŠŸèƒ½å¯èƒ½å—é™');
                }
            }
            
            if ('memory' in performance) {
                const memory = performance.memory;
                const usedPercent = (memory.usedJSHeapSize / memory.jsHeapSizeLimit) * 100;
                if (usedPercent > 80) {
                    results.push('  â€¢ å†…å­˜ä½¿ç”¨ç‡è¾ƒé«˜ï¼Œå»ºè®®å…³é—­å…¶ä»–æ ‡ç­¾é¡µ');
                }
            }
            
            results.push('  â€¢ å¦‚æœå¤„ç†å¤±è´¥ï¼Œå°è¯•ä½¿ç”¨æ›´å°çš„æµ‹è¯•è§†é¢‘');
            results.push('  â€¢ å»ºè®®è§†é¢‘æ–‡ä»¶ < 20MBï¼Œæ—¶é•¿ < 10ç§’');
            
            // æ˜¾ç¤ºæµ‹è¯•ç»“æœ
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 3000;
            `;
            
            modal.innerHTML = `
                <div style="
                    background: white;
                    padding: 24px;
                    border-radius: 12px;
                    max-width: 700px;
                    max-height: 80vh;
                    overflow-y: auto;
                    margin: 20px;
                ">
                    <h3 style="margin-bottom: 16px; color: #333;">ğŸ”§ ç³»ç»Ÿè¯Šæ–­æŠ¥å‘Š</h3>
                    <pre style="
                        white-space: pre-wrap;
                        background: #f8f9fa;
                        padding: 16px;
                        border-radius: 6px;
                        font-size: 13px;
                        line-height: 1.4;
                        color: #333;
                        margin-bottom: 16px;
                        max-height: 400px;
                        overflow-y: auto;
                    ">${results.join('\n')}</pre>
                    <div style="text-align: right;">
                        <button class="btn secondary" onclick="copyDiagnosticInfo()" style="margin-right: 8px;">
                            ğŸ“‹ å¤åˆ¶æŠ¥å‘Š
                        </button>
                        <button class="btn" onclick="this.closest('[style*=fixed]').remove()">
                            å…³é—­
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // ç‚¹å‡»èƒŒæ™¯å…³é—­
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }

        // å­˜å‚¨è¯Šæ–­ä¿¡æ¯çš„å…¨å±€å˜é‡
        let lastDiagnosticInfo = '';

        // å¤åˆ¶è¯Šæ–­ä¿¡æ¯
        function copyDiagnosticInfo() {
            if (!lastDiagnosticInfo) {
                showToast('æ²¡æœ‰å¯å¤åˆ¶çš„è¯Šæ–­ä¿¡æ¯', 'error');
                return;
            }
            
            navigator.clipboard.writeText(lastDiagnosticInfo).then(() => {
                showToast('è¯Šæ–­æŠ¥å‘Šå·²å¤åˆ¶åˆ°å‰ªè´´æ¿', 'success');
            }).catch(() => {
                // å¤‡ç”¨æ–¹æ³•
                const textArea = document.createElement('textarea');
                textArea.value = lastDiagnosticInfo;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                showToast('è¯Šæ–­æŠ¥å‘Šå·²å¤åˆ¶', 'success');
            });
        }

        // æµ‹è¯•ä¸Šä¼ åŠŸèƒ½
        function testUploadFunction() {
            const results = [];
            
            results.push('ğŸ” ä¸Šä¼ åŠŸèƒ½æµ‹è¯•:');
            
            // æ£€æŸ¥DOMå…ƒç´ 
            const uploadArea = document.getElementById('uploadArea');
            const fileInput = document.getElementById('fileInput');
            
            results.push(`  â€¢ ä¸Šä¼ åŒºåŸŸå…ƒç´ : ${uploadArea ? 'âœ… æ‰¾åˆ°' : 'âŒ æœªæ‰¾åˆ°'}`);
            results.push(`  â€¢ æ–‡ä»¶è¾“å…¥å…ƒç´ : ${fileInput ? 'âœ… æ‰¾åˆ°' : 'âŒ æœªæ‰¾åˆ°'}`);
            
            if (uploadArea) {
                results.push(`  â€¢ ä¸Šä¼ åŒºåŸŸå¯è§: ${uploadArea.offsetParent !== null ? 'âœ…' : 'âŒ'}`);
                results.push(`  â€¢ ä¸Šä¼ åŒºåŸŸå°ºå¯¸: ${uploadArea.offsetWidth}x${uploadArea.offsetHeight}`);
                
                const computedStyle = window.getComputedStyle(uploadArea);
                results.push(`  â€¢ cursoræ ·å¼: ${computedStyle.cursor}`);
                results.push(`  â€¢ pointer-events: ${computedStyle.pointerEvents}`);
                results.push(`  â€¢ z-index: ${computedStyle.zIndex}`);
            }
            
            if (fileInput) {
                results.push(`  â€¢ æ–‡ä»¶è¾“å…¥ç±»å‹: ${fileInput.type}`);
                results.push(`  â€¢ acceptå±æ€§: ${fileInput.accept}`);
                results.push(`  â€¢ multipleå±æ€§: ${fileInput.multiple ? 'âœ…' : 'âŒ'}`);
            }
            
            // æ£€æŸ¥äº‹ä»¶ç›‘å¬å™¨
            results.push('\nğŸ¯ äº‹ä»¶ç›‘å¬å™¨æµ‹è¯•:');
            
            if (uploadArea) {
                // æ¨¡æ‹Ÿç‚¹å‡»æµ‹è¯•
                try {
                    const clickEvent = new MouseEvent('click', {
                        bubbles: true,
                        cancelable: true,
                        view: window
                    });
                    
                    results.push('  â€¢ å‡†å¤‡æ¨¡æ‹Ÿç‚¹å‡»æµ‹è¯•...');
                    
                    // ä¸´æ—¶æ·»åŠ æµ‹è¯•ç›‘å¬å™¨
                    let clickDetected = false;
                    const testHandler = () => {
                        clickDetected = true;
                        results.push('  â€¢ ç‚¹å‡»äº‹ä»¶: âœ… æ£€æµ‹åˆ°');
                    };
                    
                    uploadArea.addEventListener('click', testHandler, { once: true });
                    uploadArea.dispatchEvent(clickEvent);
                    
                    setTimeout(() => {
                        if (!clickDetected) {
                            results.push('  â€¢ ç‚¹å‡»äº‹ä»¶: âŒ æœªæ£€æµ‹åˆ°');
                        }
                        
                        // æ˜¾ç¤ºæµ‹è¯•ç»“æœ
                        displayTestResults(results);
                    }, 100);
                    
                } catch (error) {
                    results.push(`  â€¢ ç‚¹å‡»æµ‹è¯•é”™è¯¯: ${error.message}`);
                    displayTestResults(results);
                }
            } else {
                displayTestResults(results);
            }
        }

        function displayTestResults(results) {
            // æ·»åŠ å»ºè®®
            results.push('\nğŸ’¡ è§£å†³å»ºè®®:');
            results.push('  â€¢ å¦‚æœä¸Šä¼ åŒºåŸŸæ— æ³•ç‚¹å‡»ï¼Œè¯·å°è¯•:');
            results.push('    - åˆ·æ–°é¡µé¢');
            results.push('    - æ£€æŸ¥æµè§ˆå™¨æ§åˆ¶å°é”™è¯¯');
            results.push('    - å°è¯•ç›´æ¥ç‚¹å‡»æ–‡ä»¶é€‰æ‹©æŒ‰é’®');
            results.push('  â€¢ å¦‚æœæ‹–æ‹½ä¸å·¥ä½œï¼Œè¯·å°è¯•:');
            results.push('    - ç¡®ä¿æ‹–æ‹½çš„æ˜¯è§†é¢‘æ–‡ä»¶');
            results.push('    - æ£€æŸ¥æ–‡ä»¶æ ¼å¼ (MP4, MOV, WebM)');
            
            // æ˜¾ç¤ºæµ‹è¯•ç»“æœçª—å£
            const modal = document.createElement('div');
            modal.style.cssText = `
                position: fixed;
                top: 0;
                left: 0;
                right: 0;
                bottom: 0;
                background: rgba(0,0,0,0.8);
                display: flex;
                justify-content: center;
                align-items: center;
                z-index: 3000;
            `;
            
            modal.innerHTML = `
                <div style="
                    background: white;
                    padding: 24px;
                    border-radius: 12px;
                    max-width: 600px;
                    max-height: 80vh;
                    overflow-y: auto;
                    margin: 20px;
                ">
                    <h3 style="margin-bottom: 16px; color: #333;">ğŸ” ä¸Šä¼ åŠŸèƒ½æµ‹è¯•æŠ¥å‘Š</h3>
                    <pre style="
                        white-space: pre-wrap;
                        background: #f8f9fa;
                        padding: 16px;
                        border-radius: 6px;
                        font-size: 13px;
                        line-height: 1.4;
                        color: #333;
                        margin-bottom: 16px;
                        max-height: 400px;
                        overflow-y: auto;
                    ">${results.join('\n')}</pre>
                    <div style="text-align: right;">
                        <button class="btn secondary" onclick="forceOpenFileDialog()" style="margin-right: 8px;">
                            ğŸ“ å¼ºåˆ¶æ‰“å¼€æ–‡ä»¶é€‰æ‹©
                        </button>
                        <button class="btn" onclick="this.closest('[style*=fixed]').remove()">
                            å…³é—­
                        </button>
                    </div>
                </div>
            `;
            
            document.body.appendChild(modal);
            
            // ç‚¹å‡»èƒŒæ™¯å…³é—­
            modal.addEventListener('click', function(e) {
                if (e.target === modal) {
                    modal.remove();
                }
            });
        }

        // å¼ºåˆ¶æ‰“å¼€æ–‡ä»¶å¯¹è¯æ¡†
        function forceOpenFileDialog() {
            console.log('å¼ºåˆ¶è§¦å‘æ–‡ä»¶é€‰æ‹©å¯¹è¯æ¡†');
            triggerFileSelection();
            showToast('å·²å°è¯•æ‰“å¼€æ–‡ä»¶é€‰æ‹©å¯¹è¯æ¡†', 'info');
        }

        // é”®ç›˜å¿«æ·é”®
        document.addEventListener('keydown', function(e) {
            if (e.ctrlKey || e.metaKey) {
                switch(e.key) {
                    case 'o':
                        e.preventDefault();
                        triggerFileSelection();
                        break;
                    case 'Enter':
                        e.preventDefault();
                        if (selectedFiles.length > 0) {
                            convertAllFiles();
                        }
                        break;
                }
            }
        });
    </script>
</body>
</html>
